=begin
#VBASoftware

#APIs for VBASoftware

The version of the OpenAPI document: v1

Generated by: https://openapi-generator.tech
Generator version: 7.12.0

=end

require 'date'
require 'time'

module Vba
  class PlanBenefits
    # Unique identifier assigned to the Plan.
    attr_accessor :plan_id

    # Unique identifier assigned to the Benefit.
    attr_accessor :benefit_code

    # Checking this option indicates that the benefit is covered only when services are rendered as the result of an accident. On the Claim Entry screen, there are options to that specify that a claim is the result of an accident. If a claim is processed against this Benefit Code without one of the accident options picked on the claim, the claim will automatically 'Deny' or 'Pend' based on the Ex Code defined on the VBA Control Panel.
    attr_accessor :accident_only

    # When checked, if the PlanBenefit_Override_Network_ID is filled out on companydata and the claim is currently out of network, change the Network ID to the PlanBenefit Override Network ID  value. Note: This field is marked as NOT NULL in the database and therefore required by the API.
    attr_accessor :always_pay_in_network

    # Total annual amount that the Plan will pay both In Network and Out of Network.
    attr_accessor :annual_max

    # Total annual amount that the Member pays both In Network and Out of Network.
    attr_accessor :annual_max_member

    # Annual amount that the Plan will pay In Network.
    attr_accessor :annual_max_net

    # Annual amount that the Member pays In Network.
    attr_accessor :annual_max_net_member

    # Annual amount that the Plan will pay Out of Network.
    attr_accessor :annual_max_oon

    # Annual amount that the Member pays Out of Network.
    attr_accessor :annual_max_oon_member

    # Applies the In-Network Co-Insurance amount toward the satisfaction of the Out-of-Network Co-Insurance maximum. Note: This field is marked as NOT NULL in the database and therefore required by the API.
    attr_accessor :co_ins_in_to_out

    # In Network Co-Insurance amount for the Family.
    attr_accessor :co_ins_max_mem

    # Total Co-Insurance amount for the Member.
    attr_accessor :co_ins_max_net_mem

    # Out of Network Co-Insurance amount for the Family.
    attr_accessor :co_ins_max_net_sub

    # Out of Network Co-Insurance amount for the Member.
    attr_accessor :co_ins_max_oon_mem

    # In Network Co-Insurance amount for the Member.
    attr_accessor :co_ins_max_oon_sub

    # Maximum CoInsurance amount for the Family per plan year.
    attr_accessor :co_ins_max_sub

    # Applies the Out-of-Network Co-Insurance amount toward the satisfaction of the In-Network Co-Insurance maximum. Note: This field is marked as NOT NULL in the database and therefore required by the API.
    attr_accessor :co_ins_out_to_in

    # When active, this will let the system know to limit the amount of co-insurance that applies to IN from OON by the Max. Note: This field is marked as NOT NULL in the database and therefore required by the API.
    attr_accessor :co_ins_out_to_in_limit

    # The max with which the co-insurance is limited by when CoIns_Out To In Limit is selected.
    attr_accessor :co_ins_out_to_in_limit_max

    # This option is informational only. Note: This field is marked as NOT NULL in the database and therefore required by the API.
    attr_accessor :coverage_24_hour

    # Identifies whether the Benefit Code is covered for this Plan. This can be populated from the 'Plan' screen. Note: This field is marked as NOT NULL in the database and therefore required by the API.
    attr_accessor :covered

    # Checking this option indicates that the Benefit is covered only when services are rendered by an In-Network provider. If a claim is processed against this Benefit Code as Out of Network, the claim will apply the “Covered In-Network Only“ Ex Code defined on the VBA Control Panel.
    attr_accessor :covered_in_net_only

    # Applies the In-Network deductible amount toward the satisfaction of the Out-of-Network deductible. Note: This field is marked as NOT NULL in the database and therefore required by the API.
    attr_accessor :ded_in_to_out

    # Applies the Out-of-Network deductible amount toward the satisfaction of the In-Network deductible. Note: This field is marked as NOT NULL in the database and therefore required by the API.
    attr_accessor :ded_out_to_in

    # When active, this will let the system know to limit the amount of deductible that applies to IN from OON by the Max. Note: This field is marked as NOT NULL in the database and therefore required by the API.
    attr_accessor :ded_out_to_in_limit

    # The max with which the deducible is limited by when Ded_Out To In Limit is selected.
    attr_accessor :ded_out_to_in_limit_max

    # This flag determines if adjudication calculates the Deductible before the CoPay is calculated. Note: This field is marked as NOT NULL in the database and therefore required by the API.
    attr_accessor :deductible_before_co_pay

    # Date when the Benefit becomes effective on this plan.
    attr_accessor :effective_date

    # Date when the record was added to the system.
    attr_accessor :entry_date

    # User that first added the record to the system.
    attr_accessor :entry_user

    # Identifies whether the Benefit Code is excluded for this Plan. This can be populated from the 'Plan' screen. Note: This field is marked as NOT NULL in the database and therefore required by the API.
    attr_accessor :excluded

    # This option is informational only. Note: This field is marked as NOT NULL in the database and therefore required by the API.
    attr_accessor :hospital_1st_day

    # Indicates that the Plan Benefit amount is included in the Plan level Maximum calculations. If this option is not specified, the Benefit is treated as a carve-out and will calculate to its own total.
    attr_accessor :include_amt_in_plan

    # Indicates that the Plan Benefit amount is included in the Plan level Co-Insurance calculations. If this option is not specified, the Benefit is treated as a carve-out and will calculate to its own total.
    attr_accessor :include_co_ins_in_plan

    # Indicates that the Plan Benefit amount is included in the Plan level Deductible calculations. If this option is not specified, the Benefit is treated as a carve-out and will calculate to its own total.
    attr_accessor :include_ded_in_plan

    # Indicates that the Plan Benefit amount is included in the Plan level Out of Pocket calculations. If this option is not specified, the Benefit is treated as a carve-out and will calculate to its own total.
    attr_accessor :include_oop_in_plan

    # Indicates if this benefits applies to the Elimination Period for claims processed under this plan.  This value would only apply if the Plan itself is configured with an Elimination Period.  This indicator will be ON by default so that the user has to specifically exclude. Note: This field is marked as NOT NULL in the database and therefore required by the API.
    attr_accessor :lt_c_applies_to_elimination_period

    # Indicates if this benefit applies to the waiting period. Note: This field is marked as NOT NULL in the database and therefore required by the API.
    attr_accessor :lt_c_applies_to_wp

    # Indicates it Inflation calculation should be applied Note: This field is marked as NOT NULL in the database and therefore required by the API.
    attr_accessor :lt_c_apply_inflation

    # Not sure about this, but I think what I want is to have one benefit defined on any plan that has a LTC Plan_Type.  You can only have one and must have one.  This is like the STD or LTD benefit on disability.  Its the benefit we use to do all the base benefit payment stuff. Note: This field is marked as NOT NULL in the database and therefore required by the API.
    attr_accessor :lt_c_base_benefit

    # This is the daily benefit amount
    attr_accessor :lt_c_daily_benefit

    # The start of the selection range for members taking this plan and choosing their daily benefit.
    attr_accessor :lt_c_daily_benefit_range_from

    # The increment of each option in the range between the from and thru.  If empty, the member can manually select a value between the from / thru range.
    attr_accessor :lt_c_daily_benefit_range_increment

    # The end of the selection range for members taking this plan and choosing their daily benefit.
    attr_accessor :lt_c_daily_benefit_range_thru

    # This is the type of daily benefit defined for this plan.  The values are:  A - a flat daily benefit enforced by the plan.  B - member selected value utilizing the daily benefit range/increment settings.
    attr_accessor :lt_c_daily_benefit_type

    # identify that this is an inflation benefit.  Would still use Covered/Rider to determine if the inflation offering is optional or not. Note: This field is marked as NOT NULL in the database and therefore required by the API.
    attr_accessor :lt_c_inflation_benefit

    # Indicates if the inflation interest is simple (0) or compunded (1). Note: This field is marked as NOT NULL in the database and therefore required by the API.
    attr_accessor :lt_c_inflation_compound

    # this is the value for the Inflation_Frequency_Type (i.e. 1 Year, 30 Days, 6 Months, etc.)
    attr_accessor :lt_c_inflation_frequency

    # indicates when the Inflation_Frequency is calculated from:  GROUP - Group Anniversary Enroll  DIV - Division Anniversary Enroll  MEMBER - Member Anniversary Enroll  PLAN - Initial Plan Enroll
    attr_accessor :lt_c_inflation_frequency_start

    # Indicates the frequency of inflation increases.  The values are:  D - Days  M - Months  Y - Years
    attr_accessor :lt_c_inflation_frequency_type

    # This value is based on Inflation_Limit_Type.  For A, this is the flat cap on inflation.  For B, this is the multiple of Limit defined as a cap (i.e. 2 for 2x limit or 2.5 for 2.5x limit)
    attr_accessor :lt_c_inflation_limit

    # the type of limit cap.  This filed only shows if Inflation_Type = B.  The 2 options are:  A - Flat Cap  B - Multipl of Limit
    attr_accessor :lt_c_inflation_limit_type

    # This is the inflation value (i.e. 5% or 6%)
    attr_accessor :lt_c_inflation_pct

    # drop down list of inflation types that change options that can be filled in.  The choices would be:  A - Simple Inflation  B - Inflation With Cap  C - Inflation No Cap
    attr_accessor :lt_c_inflation_type

    # The selectable range of days the member can pick for calculations based on days.
    attr_accessor :lt_c_lifetime_max_days_from

    # The selectable range of days the member can pick for calculations based on days.
    attr_accessor :lt_c_lifetime_max_days_thru

    # The low end range for member lifetime max selection.
    attr_accessor :lt_c_lifetime_max_from

    # the increment of options the user can select within the max range.  Empty value here means it is a free from entry of max between the range.
    attr_accessor :lt_c_lifetime_max_increment

    # the high end range for member lifetime max selection.
    attr_accessor :lt_c_lifetime_max_thru

    # Lifetime Max calculation type and will dicatate the max rules applied.  Valid values are:  STANDARD - DBM x 365 days x Lifetime Max Years selected  LMDAYS - DBM x Lifetime Max Days selected  FLAT - Lifetime Max Amount selected and not based on calculation  LMMONTHS - MBA x 12 Months x Lifetime Max Years selected
    attr_accessor :lt_c_lifetime_max_type

    # the selectable range of years the member can pick for calculations based on years.
    attr_accessor :lt_c_lifetime_max_years_from

    # the selectable range of years the member can pick for calculations based on years.
    attr_accessor :lt_c_lifetime_max_years_thru

    # This is the monthly benefit amount
    attr_accessor :lt_c_monthly_benefit

    # The start of the selection range for members taking this plan and choosing their monthly benefit.
    attr_accessor :lt_c_monthly_benefit_range_from

    # The increment of each option in the range between the from and thru.  If empty, the member can manually select a value between the from / thru range.
    attr_accessor :lt_c_monthly_benefit_range_increment

    # The end of the selection range for members taking this plan and choosing their monthly benefit.
    attr_accessor :lt_c_monthly_benefit_range_thru

    # This is the type of monthly benefit defined for this plan.  The values are:  A - a flat monthly benefit enforced by the plan.  B - member selected value utilizing the monthly benefit range/increment settings.
    attr_accessor :lt_c_monthly_benefit_type

    # the pct the be calculated against the pct_of_benefit_code.
    attr_accessor :lt_c_pct_of_benefit

    # This is the benefit code that this benefit will be a Pct of.
    attr_accessor :lt_c_pct_of_benefit_code

    # Indicates if this Benefit Code is shared across multiple members of the family AND can be used in Lifetime Max calculations to determine if the same benefit across multiple plans (same plan type) could apply together. Note: This field is marked as NOT NULL in the database and therefore required by the API.
    attr_accessor :lt_c_shared_benefit

    # Indicates if we should use this benefit DBA configuration rather than the Plan DBA. Note: This field is marked as NOT NULL in the database and therefore required by the API.
    attr_accessor :lt_c_use_benefit_dba

    # This indicates if the PlanBenefit level LBM logic should be used rather thant he parent Plan LBM settings. Note: This field is marked as NOT NULL in the database and therefore required by the API.
    attr_accessor :lt_c_use_benefit_lifetime_max

    # Indicates if we should use this benefit MBA configuration rather than the Plan MBA. Note: This field is marked as NOT NULL in the database and therefore required by the API.
    attr_accessor :lt_c_use_benefit_mba

    # This is an indicator for whether this PlanBenefit will utilize the Daily Benefit Amount or the Monthly Benefit Amount.
    attr_accessor :lt_c_use_benefit_type

    # identifies that this benefit amount is calculated as a percent of another benefit Note: This field is marked as NOT NULL in the database and therefore required by the API.
    attr_accessor :lt_c_use_pct_of_benefit

    # Total lifetime amount that the Plan will pay both In Network and Out of Network.
    attr_accessor :lifetime_max

    # Total lifetime amount that the Member pays both In Network and Out of Network.
    attr_accessor :lifetime_max_member

    # Lifetime amount that the Plan will pay In Network.
    attr_accessor :lifetime_max_net

    # Lifetime amount that the Member pays In Network.
    attr_accessor :lifetime_max_net_member

    # Lifetime amount that the Plan will pay Out of Network.
    attr_accessor :lifetime_max_oon

    # Lifetime amount that the Member pays Out of Network.
    attr_accessor :lifetime_max_oon_member

    # This option is informational only. Note: This field is marked as NOT NULL in the database and therefore required by the API.
    attr_accessor :maternity

    # Deductible amount for the Member Out of Network.
    attr_accessor :member_ded_oon

    # Deductible amount for the Member In Network.
    attr_accessor :member_ded_ppo

    # Total deductible amount for the Member both In Network and Out of Network.
    attr_accessor :member_deductible

    # Formula used to calculate the Out-of-Pocket amounts.
    attr_accessor :oo_p_calc_option

    # Applies the In-Network Out-of-Pocket amount toward the satisfaction of the Out-of-Network Out-of-Pocket maximum. Note: This field is marked as NOT NULL in the database and therefore required by the API.
    attr_accessor :oo_p_in_to_out

    # Total Out-of-Pocket amount for the Member.
    attr_accessor :oo_p_max_mem

    # Total Out-of-Pocket amount for the Member In Network.
    attr_accessor :oo_p_max_net_mem

    # Total Out-of-Pocket amount for the Family In Network.
    attr_accessor :oo_p_max_net_sub

    # Out-of-Pocket amount for the Member Out of Network.
    attr_accessor :oo_p_max_oon_mem

    # Out-of-Pocket amount for the Family Out of Network.
    attr_accessor :oo_p_max_oon_sub

    # Total Out-of-Pocket amount for the Family.
    attr_accessor :oo_p_max_sub

    # Applies the Out-of-Network Out-of-Pocket amount toward the satisfaction of the In-Network Out-of-Pocket maximum. Note: This field is marked as NOT NULL in the database and therefore required by the API.
    attr_accessor :oo_p_out_to_in

    # When active, this will let the system know to limit the amount of out of pocket that applies to IN from OON by the Max. Note: This field is marked as NOT NULL in the database and therefore required by the API.
    attr_accessor :oo_p_out_to_in_limit

    # The max with which the out of pocket is limited by when OOP_Out To In Limit is selected.
    attr_accessor :oo_p_out_to_in_limit_max

    # This option is informational only. Note: This field is marked as NOT NULL in the database and therefore required by the API.
    attr_accessor :occupational

    # Indicates that the selected Benefit applies to Primary Care Physician only. If a claim is processed against this Benefit Code without a PCP, the claim will apply the “PCP Only“ Ex Code defined on the VBA Control Panel. Note: This field is marked as NOT NULL in the database and therefore required by the API.
    attr_accessor :pc_p_only

    # Identifies if this Benefit is a parent benefit for purposes of cascading benefits. Note: This field is marked as NOT NULL in the database and therefore required by the API.
    attr_accessor :parent_benefit

    # Assigns an Ex Code that can be applied to adjudicated Subscriber claims.
    attr_accessor :pend_ex_code

    # While active, the assigned Ex Code will be applied to any adjudicated Subscriber claims.
    attr_accessor :pend_flag

    # Identifies whether the Benefit Code is a rider for this Plan. This can be populated from the 'Plan' screen. Note: This field is marked as NOT NULL in the database and therefore required by the API.
    attr_accessor :rider

    # Deductible amount for the Family Out of Network.
    attr_accessor :subscriber_ded_oon

    # Deductible amount for the Family In Network.
    attr_accessor :subscriber_ded_ppo

    # Total deductible amount for the Family both In Network and Out of Network.
    attr_accessor :subscriber_deductible

    # Date when the Benefit expires for this plan.
    attr_accessor :term_date

    # Date when the record was last updated in the system.
    attr_accessor :update_date

    # User that last updated the record in the system.
    attr_accessor :update_user

    # Indicates that the Plan Benefit Co-Insurance amounts will abide by the Plan level amounts. Note: This field is marked as NOT NULL in the database and therefore required by the API.
    attr_accessor :use_plan_co_ins

    # Indicates that the Plan Benefit Deductible amounts will abide by the Plan level amounts. Note: This field is marked as NOT NULL in the database and therefore required by the API.
    attr_accessor :use_plan_ded

    # Indicates that the Plan Benefit Maximums will abide by the Plan level amounts. Note: This field is marked as NOT NULL in the database and therefore required by the API.
    attr_accessor :use_plan_max

    # Indicates that the Plan Benefit Out of Pocket amounts will abide by the Plan level amounts. Note: This field is marked as NOT NULL in the database and therefore required by the API.
    attr_accessor :use_plan_oop

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        :'plan_id' => :'plan_ID',
        :'benefit_code' => :'benefit_Code',
        :'accident_only' => :'accident_Only',
        :'always_pay_in_network' => :'always_Pay_In_Network',
        :'annual_max' => :'annual_Max',
        :'annual_max_member' => :'annual_Max_Member',
        :'annual_max_net' => :'annual_Max_Net',
        :'annual_max_net_member' => :'annual_Max_Net_Member',
        :'annual_max_oon' => :'annual_Max_OON',
        :'annual_max_oon_member' => :'annual_Max_OON_Member',
        :'co_ins_in_to_out' => :'coIns_In_To_Out',
        :'co_ins_max_mem' => :'coIns_Max_Mem',
        :'co_ins_max_net_mem' => :'coIns_Max_Net_Mem',
        :'co_ins_max_net_sub' => :'coIns_Max_Net_Sub',
        :'co_ins_max_oon_mem' => :'coIns_Max_OON_Mem',
        :'co_ins_max_oon_sub' => :'coIns_Max_OON_Sub',
        :'co_ins_max_sub' => :'coIns_Max_Sub',
        :'co_ins_out_to_in' => :'coIns_Out_To_In',
        :'co_ins_out_to_in_limit' => :'coIns_Out_To_In_Limit',
        :'co_ins_out_to_in_limit_max' => :'coIns_Out_To_In_Limit_Max',
        :'coverage_24_hour' => :'coverage_24Hour',
        :'covered' => :'covered',
        :'covered_in_net_only' => :'covered_In_Net_Only',
        :'ded_in_to_out' => :'ded_In_To_Out',
        :'ded_out_to_in' => :'ded_Out_To_In',
        :'ded_out_to_in_limit' => :'ded_Out_To_In_Limit',
        :'ded_out_to_in_limit_max' => :'ded_Out_To_In_Limit_Max',
        :'deductible_before_co_pay' => :'deductible_Before_CoPay',
        :'effective_date' => :'effective_Date',
        :'entry_date' => :'entry_Date',
        :'entry_user' => :'entry_User',
        :'excluded' => :'excluded',
        :'hospital_1st_day' => :'hospital_1stDay',
        :'include_amt_in_plan' => :'include_Amt_In_Plan',
        :'include_co_ins_in_plan' => :'include_CoIns_In_Plan',
        :'include_ded_in_plan' => :'include_Ded_In_Plan',
        :'include_oop_in_plan' => :'include_OOP_In_Plan',
        :'lt_c_applies_to_elimination_period' => :'ltC_Applies_To_Elimination_Period',
        :'lt_c_applies_to_wp' => :'ltC_Applies_To_WP',
        :'lt_c_apply_inflation' => :'ltC_Apply_Inflation',
        :'lt_c_base_benefit' => :'ltC_Base_Benefit',
        :'lt_c_daily_benefit' => :'ltC_Daily_Benefit',
        :'lt_c_daily_benefit_range_from' => :'ltC_Daily_Benefit_Range_From',
        :'lt_c_daily_benefit_range_increment' => :'ltC_Daily_Benefit_Range_Increment',
        :'lt_c_daily_benefit_range_thru' => :'ltC_Daily_Benefit_Range_Thru',
        :'lt_c_daily_benefit_type' => :'ltC_Daily_Benefit_Type',
        :'lt_c_inflation_benefit' => :'ltC_Inflation_Benefit',
        :'lt_c_inflation_compound' => :'ltC_Inflation_Compound',
        :'lt_c_inflation_frequency' => :'ltC_Inflation_Frequency',
        :'lt_c_inflation_frequency_start' => :'ltC_Inflation_Frequency_Start',
        :'lt_c_inflation_frequency_type' => :'ltC_Inflation_Frequency_Type',
        :'lt_c_inflation_limit' => :'ltC_Inflation_Limit',
        :'lt_c_inflation_limit_type' => :'ltC_Inflation_Limit_Type',
        :'lt_c_inflation_pct' => :'ltC_Inflation_Pct',
        :'lt_c_inflation_type' => :'ltC_Inflation_Type',
        :'lt_c_lifetime_max_days_from' => :'ltC_Lifetime_Max_Days_From',
        :'lt_c_lifetime_max_days_thru' => :'ltC_Lifetime_Max_Days_Thru',
        :'lt_c_lifetime_max_from' => :'ltC_Lifetime_Max_From',
        :'lt_c_lifetime_max_increment' => :'ltC_Lifetime_Max_Increment',
        :'lt_c_lifetime_max_thru' => :'ltC_Lifetime_Max_Thru',
        :'lt_c_lifetime_max_type' => :'ltC_Lifetime_Max_Type',
        :'lt_c_lifetime_max_years_from' => :'ltC_Lifetime_Max_Years_From',
        :'lt_c_lifetime_max_years_thru' => :'ltC_Lifetime_Max_Years_Thru',
        :'lt_c_monthly_benefit' => :'ltC_Monthly_Benefit',
        :'lt_c_monthly_benefit_range_from' => :'ltC_Monthly_Benefit_Range_From',
        :'lt_c_monthly_benefit_range_increment' => :'ltC_Monthly_Benefit_Range_Increment',
        :'lt_c_monthly_benefit_range_thru' => :'ltC_Monthly_Benefit_Range_Thru',
        :'lt_c_monthly_benefit_type' => :'ltC_Monthly_Benefit_Type',
        :'lt_c_pct_of_benefit' => :'ltC_Pct_Of_Benefit',
        :'lt_c_pct_of_benefit_code' => :'ltC_Pct_Of_Benefit_Code',
        :'lt_c_shared_benefit' => :'ltC_Shared_Benefit',
        :'lt_c_use_benefit_dba' => :'ltC_Use_Benefit_DBA',
        :'lt_c_use_benefit_lifetime_max' => :'ltC_Use_Benefit_Lifetime_Max',
        :'lt_c_use_benefit_mba' => :'ltC_Use_Benefit_MBA',
        :'lt_c_use_benefit_type' => :'ltC_Use_Benefit_Type',
        :'lt_c_use_pct_of_benefit' => :'ltC_Use_Pct_Of_Benefit',
        :'lifetime_max' => :'lifetime_Max',
        :'lifetime_max_member' => :'lifetime_Max_Member',
        :'lifetime_max_net' => :'lifetime_Max_Net',
        :'lifetime_max_net_member' => :'lifetime_Max_Net_Member',
        :'lifetime_max_oon' => :'lifetime_Max_OON',
        :'lifetime_max_oon_member' => :'lifetime_Max_OON_Member',
        :'maternity' => :'maternity',
        :'member_ded_oon' => :'member_Ded_OON',
        :'member_ded_ppo' => :'member_Ded_PPO',
        :'member_deductible' => :'member_Deductible',
        :'oo_p_calc_option' => :'ooP_Calc_Option',
        :'oo_p_in_to_out' => :'ooP_In_To_Out',
        :'oo_p_max_mem' => :'ooP_Max_Mem',
        :'oo_p_max_net_mem' => :'ooP_Max_Net_Mem',
        :'oo_p_max_net_sub' => :'ooP_Max_Net_Sub',
        :'oo_p_max_oon_mem' => :'ooP_Max_OON_Mem',
        :'oo_p_max_oon_sub' => :'ooP_Max_OON_Sub',
        :'oo_p_max_sub' => :'ooP_Max_Sub',
        :'oo_p_out_to_in' => :'ooP_Out_To_In',
        :'oo_p_out_to_in_limit' => :'ooP_Out_To_In_Limit',
        :'oo_p_out_to_in_limit_max' => :'ooP_Out_To_In_Limit_Max',
        :'occupational' => :'occupational',
        :'pc_p_only' => :'pcP_Only',
        :'parent_benefit' => :'parent_Benefit',
        :'pend_ex_code' => :'pend_Ex_Code',
        :'pend_flag' => :'pend_Flag',
        :'rider' => :'rider',
        :'subscriber_ded_oon' => :'subscriber_Ded_OON',
        :'subscriber_ded_ppo' => :'subscriber_Ded_PPO',
        :'subscriber_deductible' => :'subscriber_Deductible',
        :'term_date' => :'term_Date',
        :'update_date' => :'update_Date',
        :'update_user' => :'update_User',
        :'use_plan_co_ins' => :'use_Plan_CoIns',
        :'use_plan_ded' => :'use_Plan_Ded',
        :'use_plan_max' => :'use_Plan_Max',
        :'use_plan_oop' => :'use_Plan_OOP'
      }
    end

    # Returns attribute mapping this model knows about
    def self.acceptable_attribute_map
      attribute_map
    end

    # Returns all the JSON keys this model knows about
    def self.acceptable_attributes
      acceptable_attribute_map.values
    end

    # Attribute type mapping.
    def self.openapi_types
      {
        :'plan_id' => :'String',
        :'benefit_code' => :'String',
        :'accident_only' => :'String',
        :'always_pay_in_network' => :'Boolean',
        :'annual_max' => :'Float',
        :'annual_max_member' => :'Float',
        :'annual_max_net' => :'Float',
        :'annual_max_net_member' => :'Float',
        :'annual_max_oon' => :'Float',
        :'annual_max_oon_member' => :'Float',
        :'co_ins_in_to_out' => :'Boolean',
        :'co_ins_max_mem' => :'Float',
        :'co_ins_max_net_mem' => :'Float',
        :'co_ins_max_net_sub' => :'Float',
        :'co_ins_max_oon_mem' => :'Float',
        :'co_ins_max_oon_sub' => :'Float',
        :'co_ins_max_sub' => :'Float',
        :'co_ins_out_to_in' => :'Boolean',
        :'co_ins_out_to_in_limit' => :'Boolean',
        :'co_ins_out_to_in_limit_max' => :'Float',
        :'coverage_24_hour' => :'Boolean',
        :'covered' => :'String',
        :'covered_in_net_only' => :'String',
        :'ded_in_to_out' => :'Boolean',
        :'ded_out_to_in' => :'Boolean',
        :'ded_out_to_in_limit' => :'Boolean',
        :'ded_out_to_in_limit_max' => :'Float',
        :'deductible_before_co_pay' => :'Boolean',
        :'effective_date' => :'Time',
        :'entry_date' => :'Time',
        :'entry_user' => :'String',
        :'excluded' => :'String',
        :'hospital_1st_day' => :'Boolean',
        :'include_amt_in_plan' => :'String',
        :'include_co_ins_in_plan' => :'String',
        :'include_ded_in_plan' => :'String',
        :'include_oop_in_plan' => :'String',
        :'lt_c_applies_to_elimination_period' => :'Boolean',
        :'lt_c_applies_to_wp' => :'Boolean',
        :'lt_c_apply_inflation' => :'Boolean',
        :'lt_c_base_benefit' => :'Boolean',
        :'lt_c_daily_benefit' => :'Float',
        :'lt_c_daily_benefit_range_from' => :'Float',
        :'lt_c_daily_benefit_range_increment' => :'Float',
        :'lt_c_daily_benefit_range_thru' => :'Float',
        :'lt_c_daily_benefit_type' => :'String',
        :'lt_c_inflation_benefit' => :'Boolean',
        :'lt_c_inflation_compound' => :'Boolean',
        :'lt_c_inflation_frequency' => :'Integer',
        :'lt_c_inflation_frequency_start' => :'String',
        :'lt_c_inflation_frequency_type' => :'String',
        :'lt_c_inflation_limit' => :'Float',
        :'lt_c_inflation_limit_type' => :'String',
        :'lt_c_inflation_pct' => :'Float',
        :'lt_c_inflation_type' => :'String',
        :'lt_c_lifetime_max_days_from' => :'Integer',
        :'lt_c_lifetime_max_days_thru' => :'Integer',
        :'lt_c_lifetime_max_from' => :'Float',
        :'lt_c_lifetime_max_increment' => :'Float',
        :'lt_c_lifetime_max_thru' => :'Float',
        :'lt_c_lifetime_max_type' => :'String',
        :'lt_c_lifetime_max_years_from' => :'Integer',
        :'lt_c_lifetime_max_years_thru' => :'Integer',
        :'lt_c_monthly_benefit' => :'Float',
        :'lt_c_monthly_benefit_range_from' => :'Float',
        :'lt_c_monthly_benefit_range_increment' => :'Float',
        :'lt_c_monthly_benefit_range_thru' => :'Float',
        :'lt_c_monthly_benefit_type' => :'String',
        :'lt_c_pct_of_benefit' => :'Float',
        :'lt_c_pct_of_benefit_code' => :'String',
        :'lt_c_shared_benefit' => :'Boolean',
        :'lt_c_use_benefit_dba' => :'Boolean',
        :'lt_c_use_benefit_lifetime_max' => :'Boolean',
        :'lt_c_use_benefit_mba' => :'Boolean',
        :'lt_c_use_benefit_type' => :'String',
        :'lt_c_use_pct_of_benefit' => :'Boolean',
        :'lifetime_max' => :'Float',
        :'lifetime_max_member' => :'Float',
        :'lifetime_max_net' => :'Float',
        :'lifetime_max_net_member' => :'Float',
        :'lifetime_max_oon' => :'Float',
        :'lifetime_max_oon_member' => :'Float',
        :'maternity' => :'Boolean',
        :'member_ded_oon' => :'Float',
        :'member_ded_ppo' => :'Float',
        :'member_deductible' => :'Float',
        :'oo_p_calc_option' => :'String',
        :'oo_p_in_to_out' => :'Boolean',
        :'oo_p_max_mem' => :'Float',
        :'oo_p_max_net_mem' => :'Float',
        :'oo_p_max_net_sub' => :'Float',
        :'oo_p_max_oon_mem' => :'Float',
        :'oo_p_max_oon_sub' => :'Float',
        :'oo_p_max_sub' => :'Float',
        :'oo_p_out_to_in' => :'Boolean',
        :'oo_p_out_to_in_limit' => :'Boolean',
        :'oo_p_out_to_in_limit_max' => :'Float',
        :'occupational' => :'Boolean',
        :'pc_p_only' => :'Boolean',
        :'parent_benefit' => :'Boolean',
        :'pend_ex_code' => :'String',
        :'pend_flag' => :'String',
        :'rider' => :'String',
        :'subscriber_ded_oon' => :'Float',
        :'subscriber_ded_ppo' => :'Float',
        :'subscriber_deductible' => :'Float',
        :'term_date' => :'Time',
        :'update_date' => :'Time',
        :'update_user' => :'String',
        :'use_plan_co_ins' => :'String',
        :'use_plan_ded' => :'String',
        :'use_plan_max' => :'String',
        :'use_plan_oop' => :'String'
      }
    end

    # List of attributes with nullable: true
    def self.openapi_nullable
      Set.new([
        :'accident_only',
        :'annual_max',
        :'annual_max_member',
        :'annual_max_net',
        :'annual_max_net_member',
        :'annual_max_oon',
        :'annual_max_oon_member',
        :'co_ins_max_mem',
        :'co_ins_max_net_mem',
        :'co_ins_max_net_sub',
        :'co_ins_max_oon_mem',
        :'co_ins_max_oon_sub',
        :'co_ins_max_sub',
        :'co_ins_out_to_in_limit_max',
        :'covered_in_net_only',
        :'ded_out_to_in_limit_max',
        :'effective_date',
        :'entry_user',
        :'include_amt_in_plan',
        :'include_co_ins_in_plan',
        :'include_ded_in_plan',
        :'include_oop_in_plan',
        :'lt_c_daily_benefit',
        :'lt_c_daily_benefit_range_from',
        :'lt_c_daily_benefit_range_increment',
        :'lt_c_daily_benefit_range_thru',
        :'lt_c_daily_benefit_type',
        :'lt_c_inflation_frequency',
        :'lt_c_inflation_frequency_start',
        :'lt_c_inflation_frequency_type',
        :'lt_c_inflation_limit',
        :'lt_c_inflation_limit_type',
        :'lt_c_inflation_pct',
        :'lt_c_inflation_type',
        :'lt_c_lifetime_max_days_from',
        :'lt_c_lifetime_max_days_thru',
        :'lt_c_lifetime_max_from',
        :'lt_c_lifetime_max_increment',
        :'lt_c_lifetime_max_thru',
        :'lt_c_lifetime_max_type',
        :'lt_c_lifetime_max_years_from',
        :'lt_c_lifetime_max_years_thru',
        :'lt_c_monthly_benefit',
        :'lt_c_monthly_benefit_range_from',
        :'lt_c_monthly_benefit_range_increment',
        :'lt_c_monthly_benefit_range_thru',
        :'lt_c_monthly_benefit_type',
        :'lt_c_pct_of_benefit',
        :'lt_c_pct_of_benefit_code',
        :'lt_c_use_benefit_type',
        :'lifetime_max',
        :'lifetime_max_member',
        :'lifetime_max_net',
        :'lifetime_max_net_member',
        :'lifetime_max_oon',
        :'lifetime_max_oon_member',
        :'member_ded_oon',
        :'member_ded_ppo',
        :'member_deductible',
        :'oo_p_calc_option',
        :'oo_p_max_mem',
        :'oo_p_max_net_mem',
        :'oo_p_max_net_sub',
        :'oo_p_max_oon_mem',
        :'oo_p_max_oon_sub',
        :'oo_p_max_sub',
        :'oo_p_out_to_in_limit_max',
        :'pend_ex_code',
        :'pend_flag',
        :'subscriber_ded_oon',
        :'subscriber_ded_ppo',
        :'subscriber_deductible',
        :'term_date',
        :'update_user',
      ])
    end

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(attributes = {})
      if (!attributes.is_a?(Hash))
        fail ArgumentError, "The input argument (attributes) must be a hash in `Vba::PlanBenefits` initialize method"
      end

      # check to see if the attribute exists and convert string to symbol for hash key
      acceptable_attribute_map = self.class.acceptable_attribute_map
      attributes = attributes.each_with_object({}) { |(k, v), h|
        if (!acceptable_attribute_map.key?(k.to_sym))
          fail ArgumentError, "`#{k}` is not a valid attribute in `Vba::PlanBenefits`. Please check the name to make sure it's valid. List of attributes: " + acceptable_attribute_map.keys.inspect
        end
        h[k.to_sym] = v
      }

      if attributes.key?(:'plan_id')
        self.plan_id = attributes[:'plan_id']
      else
        self.plan_id = nil
      end

      if attributes.key?(:'benefit_code')
        self.benefit_code = attributes[:'benefit_code']
      else
        self.benefit_code = nil
      end

      if attributes.key?(:'accident_only')
        self.accident_only = attributes[:'accident_only']
      end

      if attributes.key?(:'always_pay_in_network')
        self.always_pay_in_network = attributes[:'always_pay_in_network']
      else
        self.always_pay_in_network = nil
      end

      if attributes.key?(:'annual_max')
        self.annual_max = attributes[:'annual_max']
      end

      if attributes.key?(:'annual_max_member')
        self.annual_max_member = attributes[:'annual_max_member']
      end

      if attributes.key?(:'annual_max_net')
        self.annual_max_net = attributes[:'annual_max_net']
      end

      if attributes.key?(:'annual_max_net_member')
        self.annual_max_net_member = attributes[:'annual_max_net_member']
      end

      if attributes.key?(:'annual_max_oon')
        self.annual_max_oon = attributes[:'annual_max_oon']
      end

      if attributes.key?(:'annual_max_oon_member')
        self.annual_max_oon_member = attributes[:'annual_max_oon_member']
      end

      if attributes.key?(:'co_ins_in_to_out')
        self.co_ins_in_to_out = attributes[:'co_ins_in_to_out']
      else
        self.co_ins_in_to_out = nil
      end

      if attributes.key?(:'co_ins_max_mem')
        self.co_ins_max_mem = attributes[:'co_ins_max_mem']
      end

      if attributes.key?(:'co_ins_max_net_mem')
        self.co_ins_max_net_mem = attributes[:'co_ins_max_net_mem']
      end

      if attributes.key?(:'co_ins_max_net_sub')
        self.co_ins_max_net_sub = attributes[:'co_ins_max_net_sub']
      end

      if attributes.key?(:'co_ins_max_oon_mem')
        self.co_ins_max_oon_mem = attributes[:'co_ins_max_oon_mem']
      end

      if attributes.key?(:'co_ins_max_oon_sub')
        self.co_ins_max_oon_sub = attributes[:'co_ins_max_oon_sub']
      end

      if attributes.key?(:'co_ins_max_sub')
        self.co_ins_max_sub = attributes[:'co_ins_max_sub']
      end

      if attributes.key?(:'co_ins_out_to_in')
        self.co_ins_out_to_in = attributes[:'co_ins_out_to_in']
      else
        self.co_ins_out_to_in = nil
      end

      if attributes.key?(:'co_ins_out_to_in_limit')
        self.co_ins_out_to_in_limit = attributes[:'co_ins_out_to_in_limit']
      else
        self.co_ins_out_to_in_limit = nil
      end

      if attributes.key?(:'co_ins_out_to_in_limit_max')
        self.co_ins_out_to_in_limit_max = attributes[:'co_ins_out_to_in_limit_max']
      end

      if attributes.key?(:'coverage_24_hour')
        self.coverage_24_hour = attributes[:'coverage_24_hour']
      else
        self.coverage_24_hour = nil
      end

      if attributes.key?(:'covered')
        self.covered = attributes[:'covered']
      else
        self.covered = nil
      end

      if attributes.key?(:'covered_in_net_only')
        self.covered_in_net_only = attributes[:'covered_in_net_only']
      end

      if attributes.key?(:'ded_in_to_out')
        self.ded_in_to_out = attributes[:'ded_in_to_out']
      else
        self.ded_in_to_out = nil
      end

      if attributes.key?(:'ded_out_to_in')
        self.ded_out_to_in = attributes[:'ded_out_to_in']
      else
        self.ded_out_to_in = nil
      end

      if attributes.key?(:'ded_out_to_in_limit')
        self.ded_out_to_in_limit = attributes[:'ded_out_to_in_limit']
      else
        self.ded_out_to_in_limit = nil
      end

      if attributes.key?(:'ded_out_to_in_limit_max')
        self.ded_out_to_in_limit_max = attributes[:'ded_out_to_in_limit_max']
      end

      if attributes.key?(:'deductible_before_co_pay')
        self.deductible_before_co_pay = attributes[:'deductible_before_co_pay']
      else
        self.deductible_before_co_pay = nil
      end

      if attributes.key?(:'effective_date')
        self.effective_date = attributes[:'effective_date']
      end

      if attributes.key?(:'entry_date')
        self.entry_date = attributes[:'entry_date']
      end

      if attributes.key?(:'entry_user')
        self.entry_user = attributes[:'entry_user']
      end

      if attributes.key?(:'excluded')
        self.excluded = attributes[:'excluded']
      else
        self.excluded = nil
      end

      if attributes.key?(:'hospital_1st_day')
        self.hospital_1st_day = attributes[:'hospital_1st_day']
      else
        self.hospital_1st_day = nil
      end

      if attributes.key?(:'include_amt_in_plan')
        self.include_amt_in_plan = attributes[:'include_amt_in_plan']
      end

      if attributes.key?(:'include_co_ins_in_plan')
        self.include_co_ins_in_plan = attributes[:'include_co_ins_in_plan']
      end

      if attributes.key?(:'include_ded_in_plan')
        self.include_ded_in_plan = attributes[:'include_ded_in_plan']
      end

      if attributes.key?(:'include_oop_in_plan')
        self.include_oop_in_plan = attributes[:'include_oop_in_plan']
      end

      if attributes.key?(:'lt_c_applies_to_elimination_period')
        self.lt_c_applies_to_elimination_period = attributes[:'lt_c_applies_to_elimination_period']
      else
        self.lt_c_applies_to_elimination_period = nil
      end

      if attributes.key?(:'lt_c_applies_to_wp')
        self.lt_c_applies_to_wp = attributes[:'lt_c_applies_to_wp']
      else
        self.lt_c_applies_to_wp = nil
      end

      if attributes.key?(:'lt_c_apply_inflation')
        self.lt_c_apply_inflation = attributes[:'lt_c_apply_inflation']
      else
        self.lt_c_apply_inflation = nil
      end

      if attributes.key?(:'lt_c_base_benefit')
        self.lt_c_base_benefit = attributes[:'lt_c_base_benefit']
      else
        self.lt_c_base_benefit = nil
      end

      if attributes.key?(:'lt_c_daily_benefit')
        self.lt_c_daily_benefit = attributes[:'lt_c_daily_benefit']
      end

      if attributes.key?(:'lt_c_daily_benefit_range_from')
        self.lt_c_daily_benefit_range_from = attributes[:'lt_c_daily_benefit_range_from']
      end

      if attributes.key?(:'lt_c_daily_benefit_range_increment')
        self.lt_c_daily_benefit_range_increment = attributes[:'lt_c_daily_benefit_range_increment']
      end

      if attributes.key?(:'lt_c_daily_benefit_range_thru')
        self.lt_c_daily_benefit_range_thru = attributes[:'lt_c_daily_benefit_range_thru']
      end

      if attributes.key?(:'lt_c_daily_benefit_type')
        self.lt_c_daily_benefit_type = attributes[:'lt_c_daily_benefit_type']
      end

      if attributes.key?(:'lt_c_inflation_benefit')
        self.lt_c_inflation_benefit = attributes[:'lt_c_inflation_benefit']
      else
        self.lt_c_inflation_benefit = nil
      end

      if attributes.key?(:'lt_c_inflation_compound')
        self.lt_c_inflation_compound = attributes[:'lt_c_inflation_compound']
      else
        self.lt_c_inflation_compound = nil
      end

      if attributes.key?(:'lt_c_inflation_frequency')
        self.lt_c_inflation_frequency = attributes[:'lt_c_inflation_frequency']
      end

      if attributes.key?(:'lt_c_inflation_frequency_start')
        self.lt_c_inflation_frequency_start = attributes[:'lt_c_inflation_frequency_start']
      end

      if attributes.key?(:'lt_c_inflation_frequency_type')
        self.lt_c_inflation_frequency_type = attributes[:'lt_c_inflation_frequency_type']
      end

      if attributes.key?(:'lt_c_inflation_limit')
        self.lt_c_inflation_limit = attributes[:'lt_c_inflation_limit']
      end

      if attributes.key?(:'lt_c_inflation_limit_type')
        self.lt_c_inflation_limit_type = attributes[:'lt_c_inflation_limit_type']
      end

      if attributes.key?(:'lt_c_inflation_pct')
        self.lt_c_inflation_pct = attributes[:'lt_c_inflation_pct']
      end

      if attributes.key?(:'lt_c_inflation_type')
        self.lt_c_inflation_type = attributes[:'lt_c_inflation_type']
      end

      if attributes.key?(:'lt_c_lifetime_max_days_from')
        self.lt_c_lifetime_max_days_from = attributes[:'lt_c_lifetime_max_days_from']
      end

      if attributes.key?(:'lt_c_lifetime_max_days_thru')
        self.lt_c_lifetime_max_days_thru = attributes[:'lt_c_lifetime_max_days_thru']
      end

      if attributes.key?(:'lt_c_lifetime_max_from')
        self.lt_c_lifetime_max_from = attributes[:'lt_c_lifetime_max_from']
      end

      if attributes.key?(:'lt_c_lifetime_max_increment')
        self.lt_c_lifetime_max_increment = attributes[:'lt_c_lifetime_max_increment']
      end

      if attributes.key?(:'lt_c_lifetime_max_thru')
        self.lt_c_lifetime_max_thru = attributes[:'lt_c_lifetime_max_thru']
      end

      if attributes.key?(:'lt_c_lifetime_max_type')
        self.lt_c_lifetime_max_type = attributes[:'lt_c_lifetime_max_type']
      end

      if attributes.key?(:'lt_c_lifetime_max_years_from')
        self.lt_c_lifetime_max_years_from = attributes[:'lt_c_lifetime_max_years_from']
      end

      if attributes.key?(:'lt_c_lifetime_max_years_thru')
        self.lt_c_lifetime_max_years_thru = attributes[:'lt_c_lifetime_max_years_thru']
      end

      if attributes.key?(:'lt_c_monthly_benefit')
        self.lt_c_monthly_benefit = attributes[:'lt_c_monthly_benefit']
      end

      if attributes.key?(:'lt_c_monthly_benefit_range_from')
        self.lt_c_monthly_benefit_range_from = attributes[:'lt_c_monthly_benefit_range_from']
      end

      if attributes.key?(:'lt_c_monthly_benefit_range_increment')
        self.lt_c_monthly_benefit_range_increment = attributes[:'lt_c_monthly_benefit_range_increment']
      end

      if attributes.key?(:'lt_c_monthly_benefit_range_thru')
        self.lt_c_monthly_benefit_range_thru = attributes[:'lt_c_monthly_benefit_range_thru']
      end

      if attributes.key?(:'lt_c_monthly_benefit_type')
        self.lt_c_monthly_benefit_type = attributes[:'lt_c_monthly_benefit_type']
      end

      if attributes.key?(:'lt_c_pct_of_benefit')
        self.lt_c_pct_of_benefit = attributes[:'lt_c_pct_of_benefit']
      end

      if attributes.key?(:'lt_c_pct_of_benefit_code')
        self.lt_c_pct_of_benefit_code = attributes[:'lt_c_pct_of_benefit_code']
      end

      if attributes.key?(:'lt_c_shared_benefit')
        self.lt_c_shared_benefit = attributes[:'lt_c_shared_benefit']
      else
        self.lt_c_shared_benefit = nil
      end

      if attributes.key?(:'lt_c_use_benefit_dba')
        self.lt_c_use_benefit_dba = attributes[:'lt_c_use_benefit_dba']
      else
        self.lt_c_use_benefit_dba = nil
      end

      if attributes.key?(:'lt_c_use_benefit_lifetime_max')
        self.lt_c_use_benefit_lifetime_max = attributes[:'lt_c_use_benefit_lifetime_max']
      else
        self.lt_c_use_benefit_lifetime_max = nil
      end

      if attributes.key?(:'lt_c_use_benefit_mba')
        self.lt_c_use_benefit_mba = attributes[:'lt_c_use_benefit_mba']
      else
        self.lt_c_use_benefit_mba = nil
      end

      if attributes.key?(:'lt_c_use_benefit_type')
        self.lt_c_use_benefit_type = attributes[:'lt_c_use_benefit_type']
      end

      if attributes.key?(:'lt_c_use_pct_of_benefit')
        self.lt_c_use_pct_of_benefit = attributes[:'lt_c_use_pct_of_benefit']
      else
        self.lt_c_use_pct_of_benefit = nil
      end

      if attributes.key?(:'lifetime_max')
        self.lifetime_max = attributes[:'lifetime_max']
      end

      if attributes.key?(:'lifetime_max_member')
        self.lifetime_max_member = attributes[:'lifetime_max_member']
      end

      if attributes.key?(:'lifetime_max_net')
        self.lifetime_max_net = attributes[:'lifetime_max_net']
      end

      if attributes.key?(:'lifetime_max_net_member')
        self.lifetime_max_net_member = attributes[:'lifetime_max_net_member']
      end

      if attributes.key?(:'lifetime_max_oon')
        self.lifetime_max_oon = attributes[:'lifetime_max_oon']
      end

      if attributes.key?(:'lifetime_max_oon_member')
        self.lifetime_max_oon_member = attributes[:'lifetime_max_oon_member']
      end

      if attributes.key?(:'maternity')
        self.maternity = attributes[:'maternity']
      else
        self.maternity = nil
      end

      if attributes.key?(:'member_ded_oon')
        self.member_ded_oon = attributes[:'member_ded_oon']
      end

      if attributes.key?(:'member_ded_ppo')
        self.member_ded_ppo = attributes[:'member_ded_ppo']
      end

      if attributes.key?(:'member_deductible')
        self.member_deductible = attributes[:'member_deductible']
      end

      if attributes.key?(:'oo_p_calc_option')
        self.oo_p_calc_option = attributes[:'oo_p_calc_option']
      end

      if attributes.key?(:'oo_p_in_to_out')
        self.oo_p_in_to_out = attributes[:'oo_p_in_to_out']
      else
        self.oo_p_in_to_out = nil
      end

      if attributes.key?(:'oo_p_max_mem')
        self.oo_p_max_mem = attributes[:'oo_p_max_mem']
      end

      if attributes.key?(:'oo_p_max_net_mem')
        self.oo_p_max_net_mem = attributes[:'oo_p_max_net_mem']
      end

      if attributes.key?(:'oo_p_max_net_sub')
        self.oo_p_max_net_sub = attributes[:'oo_p_max_net_sub']
      end

      if attributes.key?(:'oo_p_max_oon_mem')
        self.oo_p_max_oon_mem = attributes[:'oo_p_max_oon_mem']
      end

      if attributes.key?(:'oo_p_max_oon_sub')
        self.oo_p_max_oon_sub = attributes[:'oo_p_max_oon_sub']
      end

      if attributes.key?(:'oo_p_max_sub')
        self.oo_p_max_sub = attributes[:'oo_p_max_sub']
      end

      if attributes.key?(:'oo_p_out_to_in')
        self.oo_p_out_to_in = attributes[:'oo_p_out_to_in']
      else
        self.oo_p_out_to_in = nil
      end

      if attributes.key?(:'oo_p_out_to_in_limit')
        self.oo_p_out_to_in_limit = attributes[:'oo_p_out_to_in_limit']
      else
        self.oo_p_out_to_in_limit = nil
      end

      if attributes.key?(:'oo_p_out_to_in_limit_max')
        self.oo_p_out_to_in_limit_max = attributes[:'oo_p_out_to_in_limit_max']
      end

      if attributes.key?(:'occupational')
        self.occupational = attributes[:'occupational']
      else
        self.occupational = nil
      end

      if attributes.key?(:'pc_p_only')
        self.pc_p_only = attributes[:'pc_p_only']
      else
        self.pc_p_only = nil
      end

      if attributes.key?(:'parent_benefit')
        self.parent_benefit = attributes[:'parent_benefit']
      else
        self.parent_benefit = nil
      end

      if attributes.key?(:'pend_ex_code')
        self.pend_ex_code = attributes[:'pend_ex_code']
      end

      if attributes.key?(:'pend_flag')
        self.pend_flag = attributes[:'pend_flag']
      end

      if attributes.key?(:'rider')
        self.rider = attributes[:'rider']
      else
        self.rider = nil
      end

      if attributes.key?(:'subscriber_ded_oon')
        self.subscriber_ded_oon = attributes[:'subscriber_ded_oon']
      end

      if attributes.key?(:'subscriber_ded_ppo')
        self.subscriber_ded_ppo = attributes[:'subscriber_ded_ppo']
      end

      if attributes.key?(:'subscriber_deductible')
        self.subscriber_deductible = attributes[:'subscriber_deductible']
      end

      if attributes.key?(:'term_date')
        self.term_date = attributes[:'term_date']
      end

      if attributes.key?(:'update_date')
        self.update_date = attributes[:'update_date']
      end

      if attributes.key?(:'update_user')
        self.update_user = attributes[:'update_user']
      end

      if attributes.key?(:'use_plan_co_ins')
        self.use_plan_co_ins = attributes[:'use_plan_co_ins']
      else
        self.use_plan_co_ins = nil
      end

      if attributes.key?(:'use_plan_ded')
        self.use_plan_ded = attributes[:'use_plan_ded']
      else
        self.use_plan_ded = nil
      end

      if attributes.key?(:'use_plan_max')
        self.use_plan_max = attributes[:'use_plan_max']
      else
        self.use_plan_max = nil
      end

      if attributes.key?(:'use_plan_oop')
        self.use_plan_oop = attributes[:'use_plan_oop']
      else
        self.use_plan_oop = nil
      end
    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properties with the reasons
    def list_invalid_properties
      warn '[DEPRECATED] the `list_invalid_properties` method is obsolete'
      invalid_properties = Array.new
      if @plan_id.nil?
        invalid_properties.push('invalid value for "plan_id", plan_id cannot be nil.')
      end

      if @plan_id.to_s.length > 20
        invalid_properties.push('invalid value for "plan_id", the character length must be smaller than or equal to 20.')
      end

      if @plan_id.to_s.length < 1
        invalid_properties.push('invalid value for "plan_id", the character length must be great than or equal to 1.')
      end

      if @benefit_code.nil?
        invalid_properties.push('invalid value for "benefit_code", benefit_code cannot be nil.')
      end

      if @benefit_code.to_s.length > 10
        invalid_properties.push('invalid value for "benefit_code", the character length must be smaller than or equal to 10.')
      end

      if @benefit_code.to_s.length < 1
        invalid_properties.push('invalid value for "benefit_code", the character length must be great than or equal to 1.')
      end

      if !@accident_only.nil? && @accident_only.to_s.length > 1
        invalid_properties.push('invalid value for "accident_only", the character length must be smaller than or equal to 1.')
      end

      if @always_pay_in_network.nil?
        invalid_properties.push('invalid value for "always_pay_in_network", always_pay_in_network cannot be nil.')
      end

      if @co_ins_in_to_out.nil?
        invalid_properties.push('invalid value for "co_ins_in_to_out", co_ins_in_to_out cannot be nil.')
      end

      if @co_ins_out_to_in.nil?
        invalid_properties.push('invalid value for "co_ins_out_to_in", co_ins_out_to_in cannot be nil.')
      end

      if @co_ins_out_to_in_limit.nil?
        invalid_properties.push('invalid value for "co_ins_out_to_in_limit", co_ins_out_to_in_limit cannot be nil.')
      end

      if @coverage_24_hour.nil?
        invalid_properties.push('invalid value for "coverage_24_hour", coverage_24_hour cannot be nil.')
      end

      if @covered.nil?
        invalid_properties.push('invalid value for "covered", covered cannot be nil.')
      end

      if @covered.to_s.length > 1
        invalid_properties.push('invalid value for "covered", the character length must be smaller than or equal to 1.')
      end

      if @covered.to_s.length < 1
        invalid_properties.push('invalid value for "covered", the character length must be great than or equal to 1.')
      end

      if !@covered_in_net_only.nil? && @covered_in_net_only.to_s.length > 1
        invalid_properties.push('invalid value for "covered_in_net_only", the character length must be smaller than or equal to 1.')
      end

      if @ded_in_to_out.nil?
        invalid_properties.push('invalid value for "ded_in_to_out", ded_in_to_out cannot be nil.')
      end

      if @ded_out_to_in.nil?
        invalid_properties.push('invalid value for "ded_out_to_in", ded_out_to_in cannot be nil.')
      end

      if @ded_out_to_in_limit.nil?
        invalid_properties.push('invalid value for "ded_out_to_in_limit", ded_out_to_in_limit cannot be nil.')
      end

      if @deductible_before_co_pay.nil?
        invalid_properties.push('invalid value for "deductible_before_co_pay", deductible_before_co_pay cannot be nil.')
      end

      if !@entry_user.nil? && @entry_user.to_s.length > 20
        invalid_properties.push('invalid value for "entry_user", the character length must be smaller than or equal to 20.')
      end

      if @excluded.nil?
        invalid_properties.push('invalid value for "excluded", excluded cannot be nil.')
      end

      if @excluded.to_s.length > 1
        invalid_properties.push('invalid value for "excluded", the character length must be smaller than or equal to 1.')
      end

      if @excluded.to_s.length < 1
        invalid_properties.push('invalid value for "excluded", the character length must be great than or equal to 1.')
      end

      if @hospital_1st_day.nil?
        invalid_properties.push('invalid value for "hospital_1st_day", hospital_1st_day cannot be nil.')
      end

      if !@include_amt_in_plan.nil? && @include_amt_in_plan.to_s.length > 1
        invalid_properties.push('invalid value for "include_amt_in_plan", the character length must be smaller than or equal to 1.')
      end

      if !@include_co_ins_in_plan.nil? && @include_co_ins_in_plan.to_s.length > 1
        invalid_properties.push('invalid value for "include_co_ins_in_plan", the character length must be smaller than or equal to 1.')
      end

      if !@include_ded_in_plan.nil? && @include_ded_in_plan.to_s.length > 1
        invalid_properties.push('invalid value for "include_ded_in_plan", the character length must be smaller than or equal to 1.')
      end

      if !@include_oop_in_plan.nil? && @include_oop_in_plan.to_s.length > 1
        invalid_properties.push('invalid value for "include_oop_in_plan", the character length must be smaller than or equal to 1.')
      end

      if @lt_c_applies_to_elimination_period.nil?
        invalid_properties.push('invalid value for "lt_c_applies_to_elimination_period", lt_c_applies_to_elimination_period cannot be nil.')
      end

      if @lt_c_applies_to_wp.nil?
        invalid_properties.push('invalid value for "lt_c_applies_to_wp", lt_c_applies_to_wp cannot be nil.')
      end

      if @lt_c_apply_inflation.nil?
        invalid_properties.push('invalid value for "lt_c_apply_inflation", lt_c_apply_inflation cannot be nil.')
      end

      if @lt_c_base_benefit.nil?
        invalid_properties.push('invalid value for "lt_c_base_benefit", lt_c_base_benefit cannot be nil.')
      end

      if !@lt_c_daily_benefit_type.nil? && @lt_c_daily_benefit_type.to_s.length > 32
        invalid_properties.push('invalid value for "lt_c_daily_benefit_type", the character length must be smaller than or equal to 32.')
      end

      if @lt_c_inflation_benefit.nil?
        invalid_properties.push('invalid value for "lt_c_inflation_benefit", lt_c_inflation_benefit cannot be nil.')
      end

      if @lt_c_inflation_compound.nil?
        invalid_properties.push('invalid value for "lt_c_inflation_compound", lt_c_inflation_compound cannot be nil.')
      end

      if !@lt_c_inflation_frequency_start.nil? && @lt_c_inflation_frequency_start.to_s.length > 32
        invalid_properties.push('invalid value for "lt_c_inflation_frequency_start", the character length must be smaller than or equal to 32.')
      end

      if !@lt_c_inflation_frequency_type.nil? && @lt_c_inflation_frequency_type.to_s.length > 32
        invalid_properties.push('invalid value for "lt_c_inflation_frequency_type", the character length must be smaller than or equal to 32.')
      end

      if !@lt_c_inflation_limit_type.nil? && @lt_c_inflation_limit_type.to_s.length > 32
        invalid_properties.push('invalid value for "lt_c_inflation_limit_type", the character length must be smaller than or equal to 32.')
      end

      if !@lt_c_inflation_type.nil? && @lt_c_inflation_type.to_s.length > 32
        invalid_properties.push('invalid value for "lt_c_inflation_type", the character length must be smaller than or equal to 32.')
      end

      if !@lt_c_lifetime_max_type.nil? && @lt_c_lifetime_max_type.to_s.length > 32
        invalid_properties.push('invalid value for "lt_c_lifetime_max_type", the character length must be smaller than or equal to 32.')
      end

      if !@lt_c_monthly_benefit_type.nil? && @lt_c_monthly_benefit_type.to_s.length > 32
        invalid_properties.push('invalid value for "lt_c_monthly_benefit_type", the character length must be smaller than or equal to 32.')
      end

      if !@lt_c_pct_of_benefit_code.nil? && @lt_c_pct_of_benefit_code.to_s.length > 10
        invalid_properties.push('invalid value for "lt_c_pct_of_benefit_code", the character length must be smaller than or equal to 10.')
      end

      if @lt_c_shared_benefit.nil?
        invalid_properties.push('invalid value for "lt_c_shared_benefit", lt_c_shared_benefit cannot be nil.')
      end

      if @lt_c_use_benefit_dba.nil?
        invalid_properties.push('invalid value for "lt_c_use_benefit_dba", lt_c_use_benefit_dba cannot be nil.')
      end

      if @lt_c_use_benefit_lifetime_max.nil?
        invalid_properties.push('invalid value for "lt_c_use_benefit_lifetime_max", lt_c_use_benefit_lifetime_max cannot be nil.')
      end

      if @lt_c_use_benefit_mba.nil?
        invalid_properties.push('invalid value for "lt_c_use_benefit_mba", lt_c_use_benefit_mba cannot be nil.')
      end

      if !@lt_c_use_benefit_type.nil? && @lt_c_use_benefit_type.to_s.length > 16
        invalid_properties.push('invalid value for "lt_c_use_benefit_type", the character length must be smaller than or equal to 16.')
      end

      if @lt_c_use_pct_of_benefit.nil?
        invalid_properties.push('invalid value for "lt_c_use_pct_of_benefit", lt_c_use_pct_of_benefit cannot be nil.')
      end

      if @maternity.nil?
        invalid_properties.push('invalid value for "maternity", maternity cannot be nil.')
      end

      if !@oo_p_calc_option.nil? && @oo_p_calc_option.to_s.length > 8
        invalid_properties.push('invalid value for "oo_p_calc_option", the character length must be smaller than or equal to 8.')
      end

      if @oo_p_in_to_out.nil?
        invalid_properties.push('invalid value for "oo_p_in_to_out", oo_p_in_to_out cannot be nil.')
      end

      if @oo_p_out_to_in.nil?
        invalid_properties.push('invalid value for "oo_p_out_to_in", oo_p_out_to_in cannot be nil.')
      end

      if @oo_p_out_to_in_limit.nil?
        invalid_properties.push('invalid value for "oo_p_out_to_in_limit", oo_p_out_to_in_limit cannot be nil.')
      end

      if @occupational.nil?
        invalid_properties.push('invalid value for "occupational", occupational cannot be nil.')
      end

      if @pc_p_only.nil?
        invalid_properties.push('invalid value for "pc_p_only", pc_p_only cannot be nil.')
      end

      if @parent_benefit.nil?
        invalid_properties.push('invalid value for "parent_benefit", parent_benefit cannot be nil.')
      end

      if !@pend_ex_code.nil? && @pend_ex_code.to_s.length > 6
        invalid_properties.push('invalid value for "pend_ex_code", the character length must be smaller than or equal to 6.')
      end

      if !@pend_flag.nil? && @pend_flag.to_s.length > 1
        invalid_properties.push('invalid value for "pend_flag", the character length must be smaller than or equal to 1.')
      end

      if @rider.nil?
        invalid_properties.push('invalid value for "rider", rider cannot be nil.')
      end

      if @rider.to_s.length > 1
        invalid_properties.push('invalid value for "rider", the character length must be smaller than or equal to 1.')
      end

      if @rider.to_s.length < 1
        invalid_properties.push('invalid value for "rider", the character length must be great than or equal to 1.')
      end

      if !@update_user.nil? && @update_user.to_s.length > 20
        invalid_properties.push('invalid value for "update_user", the character length must be smaller than or equal to 20.')
      end

      if @use_plan_co_ins.nil?
        invalid_properties.push('invalid value for "use_plan_co_ins", use_plan_co_ins cannot be nil.')
      end

      if @use_plan_co_ins.to_s.length > 1
        invalid_properties.push('invalid value for "use_plan_co_ins", the character length must be smaller than or equal to 1.')
      end

      if @use_plan_co_ins.to_s.length < 1
        invalid_properties.push('invalid value for "use_plan_co_ins", the character length must be great than or equal to 1.')
      end

      if @use_plan_ded.nil?
        invalid_properties.push('invalid value for "use_plan_ded", use_plan_ded cannot be nil.')
      end

      if @use_plan_ded.to_s.length > 1
        invalid_properties.push('invalid value for "use_plan_ded", the character length must be smaller than or equal to 1.')
      end

      if @use_plan_ded.to_s.length < 1
        invalid_properties.push('invalid value for "use_plan_ded", the character length must be great than or equal to 1.')
      end

      if @use_plan_max.nil?
        invalid_properties.push('invalid value for "use_plan_max", use_plan_max cannot be nil.')
      end

      if @use_plan_max.to_s.length > 1
        invalid_properties.push('invalid value for "use_plan_max", the character length must be smaller than or equal to 1.')
      end

      if @use_plan_max.to_s.length < 1
        invalid_properties.push('invalid value for "use_plan_max", the character length must be great than or equal to 1.')
      end

      if @use_plan_oop.nil?
        invalid_properties.push('invalid value for "use_plan_oop", use_plan_oop cannot be nil.')
      end

      if @use_plan_oop.to_s.length > 1
        invalid_properties.push('invalid value for "use_plan_oop", the character length must be smaller than or equal to 1.')
      end

      if @use_plan_oop.to_s.length < 1
        invalid_properties.push('invalid value for "use_plan_oop", the character length must be great than or equal to 1.')
      end

      invalid_properties
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      warn '[DEPRECATED] the `valid?` method is obsolete'
      return false if @plan_id.nil?
      return false if @plan_id.to_s.length > 20
      return false if @plan_id.to_s.length < 1
      return false if @benefit_code.nil?
      return false if @benefit_code.to_s.length > 10
      return false if @benefit_code.to_s.length < 1
      return false if !@accident_only.nil? && @accident_only.to_s.length > 1
      return false if @always_pay_in_network.nil?
      return false if @co_ins_in_to_out.nil?
      return false if @co_ins_out_to_in.nil?
      return false if @co_ins_out_to_in_limit.nil?
      return false if @coverage_24_hour.nil?
      return false if @covered.nil?
      return false if @covered.to_s.length > 1
      return false if @covered.to_s.length < 1
      return false if !@covered_in_net_only.nil? && @covered_in_net_only.to_s.length > 1
      return false if @ded_in_to_out.nil?
      return false if @ded_out_to_in.nil?
      return false if @ded_out_to_in_limit.nil?
      return false if @deductible_before_co_pay.nil?
      return false if !@entry_user.nil? && @entry_user.to_s.length > 20
      return false if @excluded.nil?
      return false if @excluded.to_s.length > 1
      return false if @excluded.to_s.length < 1
      return false if @hospital_1st_day.nil?
      return false if !@include_amt_in_plan.nil? && @include_amt_in_plan.to_s.length > 1
      return false if !@include_co_ins_in_plan.nil? && @include_co_ins_in_plan.to_s.length > 1
      return false if !@include_ded_in_plan.nil? && @include_ded_in_plan.to_s.length > 1
      return false if !@include_oop_in_plan.nil? && @include_oop_in_plan.to_s.length > 1
      return false if @lt_c_applies_to_elimination_period.nil?
      return false if @lt_c_applies_to_wp.nil?
      return false if @lt_c_apply_inflation.nil?
      return false if @lt_c_base_benefit.nil?
      return false if !@lt_c_daily_benefit_type.nil? && @lt_c_daily_benefit_type.to_s.length > 32
      return false if @lt_c_inflation_benefit.nil?
      return false if @lt_c_inflation_compound.nil?
      return false if !@lt_c_inflation_frequency_start.nil? && @lt_c_inflation_frequency_start.to_s.length > 32
      return false if !@lt_c_inflation_frequency_type.nil? && @lt_c_inflation_frequency_type.to_s.length > 32
      return false if !@lt_c_inflation_limit_type.nil? && @lt_c_inflation_limit_type.to_s.length > 32
      return false if !@lt_c_inflation_type.nil? && @lt_c_inflation_type.to_s.length > 32
      return false if !@lt_c_lifetime_max_type.nil? && @lt_c_lifetime_max_type.to_s.length > 32
      return false if !@lt_c_monthly_benefit_type.nil? && @lt_c_monthly_benefit_type.to_s.length > 32
      return false if !@lt_c_pct_of_benefit_code.nil? && @lt_c_pct_of_benefit_code.to_s.length > 10
      return false if @lt_c_shared_benefit.nil?
      return false if @lt_c_use_benefit_dba.nil?
      return false if @lt_c_use_benefit_lifetime_max.nil?
      return false if @lt_c_use_benefit_mba.nil?
      return false if !@lt_c_use_benefit_type.nil? && @lt_c_use_benefit_type.to_s.length > 16
      return false if @lt_c_use_pct_of_benefit.nil?
      return false if @maternity.nil?
      return false if !@oo_p_calc_option.nil? && @oo_p_calc_option.to_s.length > 8
      return false if @oo_p_in_to_out.nil?
      return false if @oo_p_out_to_in.nil?
      return false if @oo_p_out_to_in_limit.nil?
      return false if @occupational.nil?
      return false if @pc_p_only.nil?
      return false if @parent_benefit.nil?
      return false if !@pend_ex_code.nil? && @pend_ex_code.to_s.length > 6
      return false if !@pend_flag.nil? && @pend_flag.to_s.length > 1
      return false if @rider.nil?
      return false if @rider.to_s.length > 1
      return false if @rider.to_s.length < 1
      return false if !@update_user.nil? && @update_user.to_s.length > 20
      return false if @use_plan_co_ins.nil?
      return false if @use_plan_co_ins.to_s.length > 1
      return false if @use_plan_co_ins.to_s.length < 1
      return false if @use_plan_ded.nil?
      return false if @use_plan_ded.to_s.length > 1
      return false if @use_plan_ded.to_s.length < 1
      return false if @use_plan_max.nil?
      return false if @use_plan_max.to_s.length > 1
      return false if @use_plan_max.to_s.length < 1
      return false if @use_plan_oop.nil?
      return false if @use_plan_oop.to_s.length > 1
      return false if @use_plan_oop.to_s.length < 1
      true
    end

    # Custom attribute writer method with validation
    # @param [Object] plan_id Value to be assigned
    def plan_id=(plan_id)
      if plan_id.nil?
        fail ArgumentError, 'plan_id cannot be nil'
      end

      if plan_id.to_s.length > 20
        fail ArgumentError, 'invalid value for "plan_id", the character length must be smaller than or equal to 20.'
      end

      if plan_id.to_s.length < 1
        fail ArgumentError, 'invalid value for "plan_id", the character length must be great than or equal to 1.'
      end

      @plan_id = plan_id
    end

    # Custom attribute writer method with validation
    # @param [Object] benefit_code Value to be assigned
    def benefit_code=(benefit_code)
      if benefit_code.nil?
        fail ArgumentError, 'benefit_code cannot be nil'
      end

      if benefit_code.to_s.length > 10
        fail ArgumentError, 'invalid value for "benefit_code", the character length must be smaller than or equal to 10.'
      end

      if benefit_code.to_s.length < 1
        fail ArgumentError, 'invalid value for "benefit_code", the character length must be great than or equal to 1.'
      end

      @benefit_code = benefit_code
    end

    # Custom attribute writer method with validation
    # @param [Object] accident_only Value to be assigned
    def accident_only=(accident_only)
      if !accident_only.nil? && accident_only.to_s.length > 1
        fail ArgumentError, 'invalid value for "accident_only", the character length must be smaller than or equal to 1.'
      end

      @accident_only = accident_only
    end

    # Custom attribute writer method with validation
    # @param [Object] always_pay_in_network Value to be assigned
    def always_pay_in_network=(always_pay_in_network)
      if always_pay_in_network.nil?
        fail ArgumentError, 'always_pay_in_network cannot be nil'
      end

      @always_pay_in_network = always_pay_in_network
    end

    # Custom attribute writer method with validation
    # @param [Object] co_ins_in_to_out Value to be assigned
    def co_ins_in_to_out=(co_ins_in_to_out)
      if co_ins_in_to_out.nil?
        fail ArgumentError, 'co_ins_in_to_out cannot be nil'
      end

      @co_ins_in_to_out = co_ins_in_to_out
    end

    # Custom attribute writer method with validation
    # @param [Object] co_ins_out_to_in Value to be assigned
    def co_ins_out_to_in=(co_ins_out_to_in)
      if co_ins_out_to_in.nil?
        fail ArgumentError, 'co_ins_out_to_in cannot be nil'
      end

      @co_ins_out_to_in = co_ins_out_to_in
    end

    # Custom attribute writer method with validation
    # @param [Object] co_ins_out_to_in_limit Value to be assigned
    def co_ins_out_to_in_limit=(co_ins_out_to_in_limit)
      if co_ins_out_to_in_limit.nil?
        fail ArgumentError, 'co_ins_out_to_in_limit cannot be nil'
      end

      @co_ins_out_to_in_limit = co_ins_out_to_in_limit
    end

    # Custom attribute writer method with validation
    # @param [Object] coverage_24_hour Value to be assigned
    def coverage_24_hour=(coverage_24_hour)
      if coverage_24_hour.nil?
        fail ArgumentError, 'coverage_24_hour cannot be nil'
      end

      @coverage_24_hour = coverage_24_hour
    end

    # Custom attribute writer method with validation
    # @param [Object] covered Value to be assigned
    def covered=(covered)
      if covered.nil?
        fail ArgumentError, 'covered cannot be nil'
      end

      if covered.to_s.length > 1
        fail ArgumentError, 'invalid value for "covered", the character length must be smaller than or equal to 1.'
      end

      if covered.to_s.length < 1
        fail ArgumentError, 'invalid value for "covered", the character length must be great than or equal to 1.'
      end

      @covered = covered
    end

    # Custom attribute writer method with validation
    # @param [Object] covered_in_net_only Value to be assigned
    def covered_in_net_only=(covered_in_net_only)
      if !covered_in_net_only.nil? && covered_in_net_only.to_s.length > 1
        fail ArgumentError, 'invalid value for "covered_in_net_only", the character length must be smaller than or equal to 1.'
      end

      @covered_in_net_only = covered_in_net_only
    end

    # Custom attribute writer method with validation
    # @param [Object] ded_in_to_out Value to be assigned
    def ded_in_to_out=(ded_in_to_out)
      if ded_in_to_out.nil?
        fail ArgumentError, 'ded_in_to_out cannot be nil'
      end

      @ded_in_to_out = ded_in_to_out
    end

    # Custom attribute writer method with validation
    # @param [Object] ded_out_to_in Value to be assigned
    def ded_out_to_in=(ded_out_to_in)
      if ded_out_to_in.nil?
        fail ArgumentError, 'ded_out_to_in cannot be nil'
      end

      @ded_out_to_in = ded_out_to_in
    end

    # Custom attribute writer method with validation
    # @param [Object] ded_out_to_in_limit Value to be assigned
    def ded_out_to_in_limit=(ded_out_to_in_limit)
      if ded_out_to_in_limit.nil?
        fail ArgumentError, 'ded_out_to_in_limit cannot be nil'
      end

      @ded_out_to_in_limit = ded_out_to_in_limit
    end

    # Custom attribute writer method with validation
    # @param [Object] deductible_before_co_pay Value to be assigned
    def deductible_before_co_pay=(deductible_before_co_pay)
      if deductible_before_co_pay.nil?
        fail ArgumentError, 'deductible_before_co_pay cannot be nil'
      end

      @deductible_before_co_pay = deductible_before_co_pay
    end

    # Custom attribute writer method with validation
    # @param [Object] entry_user Value to be assigned
    def entry_user=(entry_user)
      if !entry_user.nil? && entry_user.to_s.length > 20
        fail ArgumentError, 'invalid value for "entry_user", the character length must be smaller than or equal to 20.'
      end

      @entry_user = entry_user
    end

    # Custom attribute writer method with validation
    # @param [Object] excluded Value to be assigned
    def excluded=(excluded)
      if excluded.nil?
        fail ArgumentError, 'excluded cannot be nil'
      end

      if excluded.to_s.length > 1
        fail ArgumentError, 'invalid value for "excluded", the character length must be smaller than or equal to 1.'
      end

      if excluded.to_s.length < 1
        fail ArgumentError, 'invalid value for "excluded", the character length must be great than or equal to 1.'
      end

      @excluded = excluded
    end

    # Custom attribute writer method with validation
    # @param [Object] hospital_1st_day Value to be assigned
    def hospital_1st_day=(hospital_1st_day)
      if hospital_1st_day.nil?
        fail ArgumentError, 'hospital_1st_day cannot be nil'
      end

      @hospital_1st_day = hospital_1st_day
    end

    # Custom attribute writer method with validation
    # @param [Object] include_amt_in_plan Value to be assigned
    def include_amt_in_plan=(include_amt_in_plan)
      if !include_amt_in_plan.nil? && include_amt_in_plan.to_s.length > 1
        fail ArgumentError, 'invalid value for "include_amt_in_plan", the character length must be smaller than or equal to 1.'
      end

      @include_amt_in_plan = include_amt_in_plan
    end

    # Custom attribute writer method with validation
    # @param [Object] include_co_ins_in_plan Value to be assigned
    def include_co_ins_in_plan=(include_co_ins_in_plan)
      if !include_co_ins_in_plan.nil? && include_co_ins_in_plan.to_s.length > 1
        fail ArgumentError, 'invalid value for "include_co_ins_in_plan", the character length must be smaller than or equal to 1.'
      end

      @include_co_ins_in_plan = include_co_ins_in_plan
    end

    # Custom attribute writer method with validation
    # @param [Object] include_ded_in_plan Value to be assigned
    def include_ded_in_plan=(include_ded_in_plan)
      if !include_ded_in_plan.nil? && include_ded_in_plan.to_s.length > 1
        fail ArgumentError, 'invalid value for "include_ded_in_plan", the character length must be smaller than or equal to 1.'
      end

      @include_ded_in_plan = include_ded_in_plan
    end

    # Custom attribute writer method with validation
    # @param [Object] include_oop_in_plan Value to be assigned
    def include_oop_in_plan=(include_oop_in_plan)
      if !include_oop_in_plan.nil? && include_oop_in_plan.to_s.length > 1
        fail ArgumentError, 'invalid value for "include_oop_in_plan", the character length must be smaller than or equal to 1.'
      end

      @include_oop_in_plan = include_oop_in_plan
    end

    # Custom attribute writer method with validation
    # @param [Object] lt_c_applies_to_elimination_period Value to be assigned
    def lt_c_applies_to_elimination_period=(lt_c_applies_to_elimination_period)
      if lt_c_applies_to_elimination_period.nil?
        fail ArgumentError, 'lt_c_applies_to_elimination_period cannot be nil'
      end

      @lt_c_applies_to_elimination_period = lt_c_applies_to_elimination_period
    end

    # Custom attribute writer method with validation
    # @param [Object] lt_c_applies_to_wp Value to be assigned
    def lt_c_applies_to_wp=(lt_c_applies_to_wp)
      if lt_c_applies_to_wp.nil?
        fail ArgumentError, 'lt_c_applies_to_wp cannot be nil'
      end

      @lt_c_applies_to_wp = lt_c_applies_to_wp
    end

    # Custom attribute writer method with validation
    # @param [Object] lt_c_apply_inflation Value to be assigned
    def lt_c_apply_inflation=(lt_c_apply_inflation)
      if lt_c_apply_inflation.nil?
        fail ArgumentError, 'lt_c_apply_inflation cannot be nil'
      end

      @lt_c_apply_inflation = lt_c_apply_inflation
    end

    # Custom attribute writer method with validation
    # @param [Object] lt_c_base_benefit Value to be assigned
    def lt_c_base_benefit=(lt_c_base_benefit)
      if lt_c_base_benefit.nil?
        fail ArgumentError, 'lt_c_base_benefit cannot be nil'
      end

      @lt_c_base_benefit = lt_c_base_benefit
    end

    # Custom attribute writer method with validation
    # @param [Object] lt_c_daily_benefit_type Value to be assigned
    def lt_c_daily_benefit_type=(lt_c_daily_benefit_type)
      if !lt_c_daily_benefit_type.nil? && lt_c_daily_benefit_type.to_s.length > 32
        fail ArgumentError, 'invalid value for "lt_c_daily_benefit_type", the character length must be smaller than or equal to 32.'
      end

      @lt_c_daily_benefit_type = lt_c_daily_benefit_type
    end

    # Custom attribute writer method with validation
    # @param [Object] lt_c_inflation_benefit Value to be assigned
    def lt_c_inflation_benefit=(lt_c_inflation_benefit)
      if lt_c_inflation_benefit.nil?
        fail ArgumentError, 'lt_c_inflation_benefit cannot be nil'
      end

      @lt_c_inflation_benefit = lt_c_inflation_benefit
    end

    # Custom attribute writer method with validation
    # @param [Object] lt_c_inflation_compound Value to be assigned
    def lt_c_inflation_compound=(lt_c_inflation_compound)
      if lt_c_inflation_compound.nil?
        fail ArgumentError, 'lt_c_inflation_compound cannot be nil'
      end

      @lt_c_inflation_compound = lt_c_inflation_compound
    end

    # Custom attribute writer method with validation
    # @param [Object] lt_c_inflation_frequency_start Value to be assigned
    def lt_c_inflation_frequency_start=(lt_c_inflation_frequency_start)
      if !lt_c_inflation_frequency_start.nil? && lt_c_inflation_frequency_start.to_s.length > 32
        fail ArgumentError, 'invalid value for "lt_c_inflation_frequency_start", the character length must be smaller than or equal to 32.'
      end

      @lt_c_inflation_frequency_start = lt_c_inflation_frequency_start
    end

    # Custom attribute writer method with validation
    # @param [Object] lt_c_inflation_frequency_type Value to be assigned
    def lt_c_inflation_frequency_type=(lt_c_inflation_frequency_type)
      if !lt_c_inflation_frequency_type.nil? && lt_c_inflation_frequency_type.to_s.length > 32
        fail ArgumentError, 'invalid value for "lt_c_inflation_frequency_type", the character length must be smaller than or equal to 32.'
      end

      @lt_c_inflation_frequency_type = lt_c_inflation_frequency_type
    end

    # Custom attribute writer method with validation
    # @param [Object] lt_c_inflation_limit_type Value to be assigned
    def lt_c_inflation_limit_type=(lt_c_inflation_limit_type)
      if !lt_c_inflation_limit_type.nil? && lt_c_inflation_limit_type.to_s.length > 32
        fail ArgumentError, 'invalid value for "lt_c_inflation_limit_type", the character length must be smaller than or equal to 32.'
      end

      @lt_c_inflation_limit_type = lt_c_inflation_limit_type
    end

    # Custom attribute writer method with validation
    # @param [Object] lt_c_inflation_type Value to be assigned
    def lt_c_inflation_type=(lt_c_inflation_type)
      if !lt_c_inflation_type.nil? && lt_c_inflation_type.to_s.length > 32
        fail ArgumentError, 'invalid value for "lt_c_inflation_type", the character length must be smaller than or equal to 32.'
      end

      @lt_c_inflation_type = lt_c_inflation_type
    end

    # Custom attribute writer method with validation
    # @param [Object] lt_c_lifetime_max_type Value to be assigned
    def lt_c_lifetime_max_type=(lt_c_lifetime_max_type)
      if !lt_c_lifetime_max_type.nil? && lt_c_lifetime_max_type.to_s.length > 32
        fail ArgumentError, 'invalid value for "lt_c_lifetime_max_type", the character length must be smaller than or equal to 32.'
      end

      @lt_c_lifetime_max_type = lt_c_lifetime_max_type
    end

    # Custom attribute writer method with validation
    # @param [Object] lt_c_monthly_benefit_type Value to be assigned
    def lt_c_monthly_benefit_type=(lt_c_monthly_benefit_type)
      if !lt_c_monthly_benefit_type.nil? && lt_c_monthly_benefit_type.to_s.length > 32
        fail ArgumentError, 'invalid value for "lt_c_monthly_benefit_type", the character length must be smaller than or equal to 32.'
      end

      @lt_c_monthly_benefit_type = lt_c_monthly_benefit_type
    end

    # Custom attribute writer method with validation
    # @param [Object] lt_c_pct_of_benefit_code Value to be assigned
    def lt_c_pct_of_benefit_code=(lt_c_pct_of_benefit_code)
      if !lt_c_pct_of_benefit_code.nil? && lt_c_pct_of_benefit_code.to_s.length > 10
        fail ArgumentError, 'invalid value for "lt_c_pct_of_benefit_code", the character length must be smaller than or equal to 10.'
      end

      @lt_c_pct_of_benefit_code = lt_c_pct_of_benefit_code
    end

    # Custom attribute writer method with validation
    # @param [Object] lt_c_shared_benefit Value to be assigned
    def lt_c_shared_benefit=(lt_c_shared_benefit)
      if lt_c_shared_benefit.nil?
        fail ArgumentError, 'lt_c_shared_benefit cannot be nil'
      end

      @lt_c_shared_benefit = lt_c_shared_benefit
    end

    # Custom attribute writer method with validation
    # @param [Object] lt_c_use_benefit_dba Value to be assigned
    def lt_c_use_benefit_dba=(lt_c_use_benefit_dba)
      if lt_c_use_benefit_dba.nil?
        fail ArgumentError, 'lt_c_use_benefit_dba cannot be nil'
      end

      @lt_c_use_benefit_dba = lt_c_use_benefit_dba
    end

    # Custom attribute writer method with validation
    # @param [Object] lt_c_use_benefit_lifetime_max Value to be assigned
    def lt_c_use_benefit_lifetime_max=(lt_c_use_benefit_lifetime_max)
      if lt_c_use_benefit_lifetime_max.nil?
        fail ArgumentError, 'lt_c_use_benefit_lifetime_max cannot be nil'
      end

      @lt_c_use_benefit_lifetime_max = lt_c_use_benefit_lifetime_max
    end

    # Custom attribute writer method with validation
    # @param [Object] lt_c_use_benefit_mba Value to be assigned
    def lt_c_use_benefit_mba=(lt_c_use_benefit_mba)
      if lt_c_use_benefit_mba.nil?
        fail ArgumentError, 'lt_c_use_benefit_mba cannot be nil'
      end

      @lt_c_use_benefit_mba = lt_c_use_benefit_mba
    end

    # Custom attribute writer method with validation
    # @param [Object] lt_c_use_benefit_type Value to be assigned
    def lt_c_use_benefit_type=(lt_c_use_benefit_type)
      if !lt_c_use_benefit_type.nil? && lt_c_use_benefit_type.to_s.length > 16
        fail ArgumentError, 'invalid value for "lt_c_use_benefit_type", the character length must be smaller than or equal to 16.'
      end

      @lt_c_use_benefit_type = lt_c_use_benefit_type
    end

    # Custom attribute writer method with validation
    # @param [Object] lt_c_use_pct_of_benefit Value to be assigned
    def lt_c_use_pct_of_benefit=(lt_c_use_pct_of_benefit)
      if lt_c_use_pct_of_benefit.nil?
        fail ArgumentError, 'lt_c_use_pct_of_benefit cannot be nil'
      end

      @lt_c_use_pct_of_benefit = lt_c_use_pct_of_benefit
    end

    # Custom attribute writer method with validation
    # @param [Object] maternity Value to be assigned
    def maternity=(maternity)
      if maternity.nil?
        fail ArgumentError, 'maternity cannot be nil'
      end

      @maternity = maternity
    end

    # Custom attribute writer method with validation
    # @param [Object] oo_p_calc_option Value to be assigned
    def oo_p_calc_option=(oo_p_calc_option)
      if !oo_p_calc_option.nil? && oo_p_calc_option.to_s.length > 8
        fail ArgumentError, 'invalid value for "oo_p_calc_option", the character length must be smaller than or equal to 8.'
      end

      @oo_p_calc_option = oo_p_calc_option
    end

    # Custom attribute writer method with validation
    # @param [Object] oo_p_in_to_out Value to be assigned
    def oo_p_in_to_out=(oo_p_in_to_out)
      if oo_p_in_to_out.nil?
        fail ArgumentError, 'oo_p_in_to_out cannot be nil'
      end

      @oo_p_in_to_out = oo_p_in_to_out
    end

    # Custom attribute writer method with validation
    # @param [Object] oo_p_out_to_in Value to be assigned
    def oo_p_out_to_in=(oo_p_out_to_in)
      if oo_p_out_to_in.nil?
        fail ArgumentError, 'oo_p_out_to_in cannot be nil'
      end

      @oo_p_out_to_in = oo_p_out_to_in
    end

    # Custom attribute writer method with validation
    # @param [Object] oo_p_out_to_in_limit Value to be assigned
    def oo_p_out_to_in_limit=(oo_p_out_to_in_limit)
      if oo_p_out_to_in_limit.nil?
        fail ArgumentError, 'oo_p_out_to_in_limit cannot be nil'
      end

      @oo_p_out_to_in_limit = oo_p_out_to_in_limit
    end

    # Custom attribute writer method with validation
    # @param [Object] occupational Value to be assigned
    def occupational=(occupational)
      if occupational.nil?
        fail ArgumentError, 'occupational cannot be nil'
      end

      @occupational = occupational
    end

    # Custom attribute writer method with validation
    # @param [Object] pc_p_only Value to be assigned
    def pc_p_only=(pc_p_only)
      if pc_p_only.nil?
        fail ArgumentError, 'pc_p_only cannot be nil'
      end

      @pc_p_only = pc_p_only
    end

    # Custom attribute writer method with validation
    # @param [Object] parent_benefit Value to be assigned
    def parent_benefit=(parent_benefit)
      if parent_benefit.nil?
        fail ArgumentError, 'parent_benefit cannot be nil'
      end

      @parent_benefit = parent_benefit
    end

    # Custom attribute writer method with validation
    # @param [Object] pend_ex_code Value to be assigned
    def pend_ex_code=(pend_ex_code)
      if !pend_ex_code.nil? && pend_ex_code.to_s.length > 6
        fail ArgumentError, 'invalid value for "pend_ex_code", the character length must be smaller than or equal to 6.'
      end

      @pend_ex_code = pend_ex_code
    end

    # Custom attribute writer method with validation
    # @param [Object] pend_flag Value to be assigned
    def pend_flag=(pend_flag)
      if !pend_flag.nil? && pend_flag.to_s.length > 1
        fail ArgumentError, 'invalid value for "pend_flag", the character length must be smaller than or equal to 1.'
      end

      @pend_flag = pend_flag
    end

    # Custom attribute writer method with validation
    # @param [Object] rider Value to be assigned
    def rider=(rider)
      if rider.nil?
        fail ArgumentError, 'rider cannot be nil'
      end

      if rider.to_s.length > 1
        fail ArgumentError, 'invalid value for "rider", the character length must be smaller than or equal to 1.'
      end

      if rider.to_s.length < 1
        fail ArgumentError, 'invalid value for "rider", the character length must be great than or equal to 1.'
      end

      @rider = rider
    end

    # Custom attribute writer method with validation
    # @param [Object] update_user Value to be assigned
    def update_user=(update_user)
      if !update_user.nil? && update_user.to_s.length > 20
        fail ArgumentError, 'invalid value for "update_user", the character length must be smaller than or equal to 20.'
      end

      @update_user = update_user
    end

    # Custom attribute writer method with validation
    # @param [Object] use_plan_co_ins Value to be assigned
    def use_plan_co_ins=(use_plan_co_ins)
      if use_plan_co_ins.nil?
        fail ArgumentError, 'use_plan_co_ins cannot be nil'
      end

      if use_plan_co_ins.to_s.length > 1
        fail ArgumentError, 'invalid value for "use_plan_co_ins", the character length must be smaller than or equal to 1.'
      end

      if use_plan_co_ins.to_s.length < 1
        fail ArgumentError, 'invalid value for "use_plan_co_ins", the character length must be great than or equal to 1.'
      end

      @use_plan_co_ins = use_plan_co_ins
    end

    # Custom attribute writer method with validation
    # @param [Object] use_plan_ded Value to be assigned
    def use_plan_ded=(use_plan_ded)
      if use_plan_ded.nil?
        fail ArgumentError, 'use_plan_ded cannot be nil'
      end

      if use_plan_ded.to_s.length > 1
        fail ArgumentError, 'invalid value for "use_plan_ded", the character length must be smaller than or equal to 1.'
      end

      if use_plan_ded.to_s.length < 1
        fail ArgumentError, 'invalid value for "use_plan_ded", the character length must be great than or equal to 1.'
      end

      @use_plan_ded = use_plan_ded
    end

    # Custom attribute writer method with validation
    # @param [Object] use_plan_max Value to be assigned
    def use_plan_max=(use_plan_max)
      if use_plan_max.nil?
        fail ArgumentError, 'use_plan_max cannot be nil'
      end

      if use_plan_max.to_s.length > 1
        fail ArgumentError, 'invalid value for "use_plan_max", the character length must be smaller than or equal to 1.'
      end

      if use_plan_max.to_s.length < 1
        fail ArgumentError, 'invalid value for "use_plan_max", the character length must be great than or equal to 1.'
      end

      @use_plan_max = use_plan_max
    end

    # Custom attribute writer method with validation
    # @param [Object] use_plan_oop Value to be assigned
    def use_plan_oop=(use_plan_oop)
      if use_plan_oop.nil?
        fail ArgumentError, 'use_plan_oop cannot be nil'
      end

      if use_plan_oop.to_s.length > 1
        fail ArgumentError, 'invalid value for "use_plan_oop", the character length must be smaller than or equal to 1.'
      end

      if use_plan_oop.to_s.length < 1
        fail ArgumentError, 'invalid value for "use_plan_oop", the character length must be great than or equal to 1.'
      end

      @use_plan_oop = use_plan_oop
    end

    # Checks equality by comparing each attribute.
    # @param [Object] Object to be compared
    def ==(o)
      return true if self.equal?(o)
      self.class == o.class &&
          plan_id == o.plan_id &&
          benefit_code == o.benefit_code &&
          accident_only == o.accident_only &&
          always_pay_in_network == o.always_pay_in_network &&
          annual_max == o.annual_max &&
          annual_max_member == o.annual_max_member &&
          annual_max_net == o.annual_max_net &&
          annual_max_net_member == o.annual_max_net_member &&
          annual_max_oon == o.annual_max_oon &&
          annual_max_oon_member == o.annual_max_oon_member &&
          co_ins_in_to_out == o.co_ins_in_to_out &&
          co_ins_max_mem == o.co_ins_max_mem &&
          co_ins_max_net_mem == o.co_ins_max_net_mem &&
          co_ins_max_net_sub == o.co_ins_max_net_sub &&
          co_ins_max_oon_mem == o.co_ins_max_oon_mem &&
          co_ins_max_oon_sub == o.co_ins_max_oon_sub &&
          co_ins_max_sub == o.co_ins_max_sub &&
          co_ins_out_to_in == o.co_ins_out_to_in &&
          co_ins_out_to_in_limit == o.co_ins_out_to_in_limit &&
          co_ins_out_to_in_limit_max == o.co_ins_out_to_in_limit_max &&
          coverage_24_hour == o.coverage_24_hour &&
          covered == o.covered &&
          covered_in_net_only == o.covered_in_net_only &&
          ded_in_to_out == o.ded_in_to_out &&
          ded_out_to_in == o.ded_out_to_in &&
          ded_out_to_in_limit == o.ded_out_to_in_limit &&
          ded_out_to_in_limit_max == o.ded_out_to_in_limit_max &&
          deductible_before_co_pay == o.deductible_before_co_pay &&
          effective_date == o.effective_date &&
          entry_date == o.entry_date &&
          entry_user == o.entry_user &&
          excluded == o.excluded &&
          hospital_1st_day == o.hospital_1st_day &&
          include_amt_in_plan == o.include_amt_in_plan &&
          include_co_ins_in_plan == o.include_co_ins_in_plan &&
          include_ded_in_plan == o.include_ded_in_plan &&
          include_oop_in_plan == o.include_oop_in_plan &&
          lt_c_applies_to_elimination_period == o.lt_c_applies_to_elimination_period &&
          lt_c_applies_to_wp == o.lt_c_applies_to_wp &&
          lt_c_apply_inflation == o.lt_c_apply_inflation &&
          lt_c_base_benefit == o.lt_c_base_benefit &&
          lt_c_daily_benefit == o.lt_c_daily_benefit &&
          lt_c_daily_benefit_range_from == o.lt_c_daily_benefit_range_from &&
          lt_c_daily_benefit_range_increment == o.lt_c_daily_benefit_range_increment &&
          lt_c_daily_benefit_range_thru == o.lt_c_daily_benefit_range_thru &&
          lt_c_daily_benefit_type == o.lt_c_daily_benefit_type &&
          lt_c_inflation_benefit == o.lt_c_inflation_benefit &&
          lt_c_inflation_compound == o.lt_c_inflation_compound &&
          lt_c_inflation_frequency == o.lt_c_inflation_frequency &&
          lt_c_inflation_frequency_start == o.lt_c_inflation_frequency_start &&
          lt_c_inflation_frequency_type == o.lt_c_inflation_frequency_type &&
          lt_c_inflation_limit == o.lt_c_inflation_limit &&
          lt_c_inflation_limit_type == o.lt_c_inflation_limit_type &&
          lt_c_inflation_pct == o.lt_c_inflation_pct &&
          lt_c_inflation_type == o.lt_c_inflation_type &&
          lt_c_lifetime_max_days_from == o.lt_c_lifetime_max_days_from &&
          lt_c_lifetime_max_days_thru == o.lt_c_lifetime_max_days_thru &&
          lt_c_lifetime_max_from == o.lt_c_lifetime_max_from &&
          lt_c_lifetime_max_increment == o.lt_c_lifetime_max_increment &&
          lt_c_lifetime_max_thru == o.lt_c_lifetime_max_thru &&
          lt_c_lifetime_max_type == o.lt_c_lifetime_max_type &&
          lt_c_lifetime_max_years_from == o.lt_c_lifetime_max_years_from &&
          lt_c_lifetime_max_years_thru == o.lt_c_lifetime_max_years_thru &&
          lt_c_monthly_benefit == o.lt_c_monthly_benefit &&
          lt_c_monthly_benefit_range_from == o.lt_c_monthly_benefit_range_from &&
          lt_c_monthly_benefit_range_increment == o.lt_c_monthly_benefit_range_increment &&
          lt_c_monthly_benefit_range_thru == o.lt_c_monthly_benefit_range_thru &&
          lt_c_monthly_benefit_type == o.lt_c_monthly_benefit_type &&
          lt_c_pct_of_benefit == o.lt_c_pct_of_benefit &&
          lt_c_pct_of_benefit_code == o.lt_c_pct_of_benefit_code &&
          lt_c_shared_benefit == o.lt_c_shared_benefit &&
          lt_c_use_benefit_dba == o.lt_c_use_benefit_dba &&
          lt_c_use_benefit_lifetime_max == o.lt_c_use_benefit_lifetime_max &&
          lt_c_use_benefit_mba == o.lt_c_use_benefit_mba &&
          lt_c_use_benefit_type == o.lt_c_use_benefit_type &&
          lt_c_use_pct_of_benefit == o.lt_c_use_pct_of_benefit &&
          lifetime_max == o.lifetime_max &&
          lifetime_max_member == o.lifetime_max_member &&
          lifetime_max_net == o.lifetime_max_net &&
          lifetime_max_net_member == o.lifetime_max_net_member &&
          lifetime_max_oon == o.lifetime_max_oon &&
          lifetime_max_oon_member == o.lifetime_max_oon_member &&
          maternity == o.maternity &&
          member_ded_oon == o.member_ded_oon &&
          member_ded_ppo == o.member_ded_ppo &&
          member_deductible == o.member_deductible &&
          oo_p_calc_option == o.oo_p_calc_option &&
          oo_p_in_to_out == o.oo_p_in_to_out &&
          oo_p_max_mem == o.oo_p_max_mem &&
          oo_p_max_net_mem == o.oo_p_max_net_mem &&
          oo_p_max_net_sub == o.oo_p_max_net_sub &&
          oo_p_max_oon_mem == o.oo_p_max_oon_mem &&
          oo_p_max_oon_sub == o.oo_p_max_oon_sub &&
          oo_p_max_sub == o.oo_p_max_sub &&
          oo_p_out_to_in == o.oo_p_out_to_in &&
          oo_p_out_to_in_limit == o.oo_p_out_to_in_limit &&
          oo_p_out_to_in_limit_max == o.oo_p_out_to_in_limit_max &&
          occupational == o.occupational &&
          pc_p_only == o.pc_p_only &&
          parent_benefit == o.parent_benefit &&
          pend_ex_code == o.pend_ex_code &&
          pend_flag == o.pend_flag &&
          rider == o.rider &&
          subscriber_ded_oon == o.subscriber_ded_oon &&
          subscriber_ded_ppo == o.subscriber_ded_ppo &&
          subscriber_deductible == o.subscriber_deductible &&
          term_date == o.term_date &&
          update_date == o.update_date &&
          update_user == o.update_user &&
          use_plan_co_ins == o.use_plan_co_ins &&
          use_plan_ded == o.use_plan_ded &&
          use_plan_max == o.use_plan_max &&
          use_plan_oop == o.use_plan_oop
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(o)
      self == o
    end

    # Calculates hash code according to all attributes.
    # @return [Integer] Hash code
    def hash
      [plan_id, benefit_code, accident_only, always_pay_in_network, annual_max, annual_max_member, annual_max_net, annual_max_net_member, annual_max_oon, annual_max_oon_member, co_ins_in_to_out, co_ins_max_mem, co_ins_max_net_mem, co_ins_max_net_sub, co_ins_max_oon_mem, co_ins_max_oon_sub, co_ins_max_sub, co_ins_out_to_in, co_ins_out_to_in_limit, co_ins_out_to_in_limit_max, coverage_24_hour, covered, covered_in_net_only, ded_in_to_out, ded_out_to_in, ded_out_to_in_limit, ded_out_to_in_limit_max, deductible_before_co_pay, effective_date, entry_date, entry_user, excluded, hospital_1st_day, include_amt_in_plan, include_co_ins_in_plan, include_ded_in_plan, include_oop_in_plan, lt_c_applies_to_elimination_period, lt_c_applies_to_wp, lt_c_apply_inflation, lt_c_base_benefit, lt_c_daily_benefit, lt_c_daily_benefit_range_from, lt_c_daily_benefit_range_increment, lt_c_daily_benefit_range_thru, lt_c_daily_benefit_type, lt_c_inflation_benefit, lt_c_inflation_compound, lt_c_inflation_frequency, lt_c_inflation_frequency_start, lt_c_inflation_frequency_type, lt_c_inflation_limit, lt_c_inflation_limit_type, lt_c_inflation_pct, lt_c_inflation_type, lt_c_lifetime_max_days_from, lt_c_lifetime_max_days_thru, lt_c_lifetime_max_from, lt_c_lifetime_max_increment, lt_c_lifetime_max_thru, lt_c_lifetime_max_type, lt_c_lifetime_max_years_from, lt_c_lifetime_max_years_thru, lt_c_monthly_benefit, lt_c_monthly_benefit_range_from, lt_c_monthly_benefit_range_increment, lt_c_monthly_benefit_range_thru, lt_c_monthly_benefit_type, lt_c_pct_of_benefit, lt_c_pct_of_benefit_code, lt_c_shared_benefit, lt_c_use_benefit_dba, lt_c_use_benefit_lifetime_max, lt_c_use_benefit_mba, lt_c_use_benefit_type, lt_c_use_pct_of_benefit, lifetime_max, lifetime_max_member, lifetime_max_net, lifetime_max_net_member, lifetime_max_oon, lifetime_max_oon_member, maternity, member_ded_oon, member_ded_ppo, member_deductible, oo_p_calc_option, oo_p_in_to_out, oo_p_max_mem, oo_p_max_net_mem, oo_p_max_net_sub, oo_p_max_oon_mem, oo_p_max_oon_sub, oo_p_max_sub, oo_p_out_to_in, oo_p_out_to_in_limit, oo_p_out_to_in_limit_max, occupational, pc_p_only, parent_benefit, pend_ex_code, pend_flag, rider, subscriber_ded_oon, subscriber_ded_ppo, subscriber_deductible, term_date, update_date, update_user, use_plan_co_ins, use_plan_ded, use_plan_max, use_plan_oop].hash
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def self.build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)
      attributes = attributes.transform_keys(&:to_sym)
      transformed_hash = {}
      openapi_types.each_pair do |key, type|
        if attributes.key?(attribute_map[key]) && attributes[attribute_map[key]].nil?
          transformed_hash["#{key}"] = nil
        elsif type =~ /\AArray<(.*)>/i
          # check to ensure the input is an array given that the attribute
          # is documented as an array but the input is not
          if attributes[attribute_map[key]].is_a?(Array)
            transformed_hash["#{key}"] = attributes[attribute_map[key]].map { |v| _deserialize($1, v) }
          end
        elsif !attributes[attribute_map[key]].nil?
          transformed_hash["#{key}"] = _deserialize(type, attributes[attribute_map[key]])
        end
      end
      new(transformed_hash)
    end

    # Deserializes the data based on type
    # @param string type Data type
    # @param string value Value to be deserialized
    # @return [Object] Deserialized data
    def self._deserialize(type, value)
      case type.to_sym
      when :Time
        Time.parse(value)
      when :Date
        Date.parse(value)
      when :String
        value.to_s
      when :Integer
        value.to_i
      when :Float
        value.to_f
      when :Boolean
        if value.to_s =~ /\A(true|t|yes|y|1)\z/i
          true
        else
          false
        end
      when :Object
        # generic object (usually a Hash), return directly
        value
      when /\AArray<(?<inner_type>.+)>\z/
        inner_type = Regexp.last_match[:inner_type]
        value.map { |v| _deserialize(inner_type, v) }
      when /\AHash<(?<k_type>.+?), (?<v_type>.+)>\z/
        k_type = Regexp.last_match[:k_type]
        v_type = Regexp.last_match[:v_type]
        {}.tap do |hash|
          value.each do |k, v|
            hash[_deserialize(k_type, k)] = _deserialize(v_type, v)
          end
        end
      else # model
        # models (e.g. Pet) or oneOf
        klass = Vba.const_get(type)
        klass.respond_to?(:openapi_any_of) || klass.respond_to?(:openapi_one_of) ? klass.build(value) : klass.build_from_hash(value)
      end
    end

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # to_body is an alias to to_hash (backward compatibility)
    # @return [Hash] Returns the object in the form of hash
    def to_body
      to_hash
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = self.send(attr)
        if value.nil?
          is_nullable = self.class.openapi_nullable.include?(attr)
          next if !is_nullable || (is_nullable && !instance_variable_defined?(:"@#{attr}"))
        end

        hash[param] = _to_hash(value)
      end
      hash
    end

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map { |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end

  end

end
